{
    "HighRiskFindings": {
        "A previously timelocked NFT token becomes permanently stuck in vault if it\u2019s ever moved back into the vault": [
            "_Submitted by 0xRajeev, also found by pauliax_",
            "Let\u2019s consider a scenario where a particular NFT token was timelocked for a certain duration by the owner using `timeLockERC721()` with a delegate as the recipient and then transferred out of the vault by the delegate via `transferERC721()` but without unlocking it explicitly using `timeUnlockERC721()`.",
            "This is possible because `transferERC721()` does all the timelock checks on `expires/block.timestamp` and `recipient/msg.sender` as is done in `timeUnlockERC721()`. But it misses deleting `timelockERC721s[key]` for that NFT `tokenID` (as done in L572 of `timeUnlockERC721()`).",
            "Because of this missing deletion, if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the `transferERC721()` call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock).",
            "The impact is that, without access/control to the earlier timelock recipient, this NFT token is now locked in the vault forever.",
            "1. Alice time locks a particular NFT token with delegate Eve as recipient using `timeLockERC721()`",
            "2. Eve transfers NFT to Bob using `transferERC721()` but without calling `timeUnlockERC721()` first",
            "3. Alice buys the same NFT back from Bob (e.g. because it is now considered rare and more valuable) and again puts it back in her vault but this time without locking/delegating it to any recipient i.e. intending to control it herself.",
            "4. Because this NFT's timelock data and delegate approval for Eve is never removed after Step 2, the NFT is still treated as timelocked in the vault with previous delegate Eve as the recipient (because of stale data in `timelockERC721s` and `nftApprovals`)",
            "5. Alice now cannot withdraw her own NFT without Eve\u2019s help because the check on L510 will only allow Eve to transfer this NFT out of the vault.",
            "6. If Eve is no longer trusted/accessible then the NFT is locked in the vault forever.",
            "Recommend adding `delete timelockERC721s [timelockERC721Keys[nftContract][i]];` after L510.",
            "**[xyz-ctrl (Visor) confirmed](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/35#issuecomment-857003620):**",
            "**[ztcrypto (Visor) patched](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/35#issuecomment-889188488):**",
            "> patch [link](https://github.com/VisorFinance/visor-core/commit/71797204108fee8375bfb99a435c0e379bbcbd84#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)"
        ],
        "NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens": [
            "_Submitted by 0xRajeev, also found by shw_",
            "NFT transfer approvals that are set to true in `approveTransferERC721()` are never set to false and there is no way to remove such an nft approval.",
            "**Impact 1**: The approval is not removed (set to false) after a transfer in `transferERC721()`. So if the NFT is ever moved back into the owner's vault again, then the previous/compromised delegate can again transfer it to any address of choice without requiring a new approval.",
            "**Impact 2**: If a delegate becomes compromised/untrustworthy after granting approval but before transfer then the owner will lose its NFT because there is no mechanism to revoke the approval that was granted earlier.",
            "[PoC-1](https://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L477-L487):",
            "* Alice grants Eve approval to transfer a particular NFT out of its vault using `approveTransferERC721()`",
            "* Eve, who has transfer rights to that NFT from Alice\u2019s vault,  transfers that NFT to Bob using `transferERC721()`",
            "* Alice decides to buy back that NFT (e.g. because it is now considered rare and more valuable) from Bob and transfers it back to its vault",
            "* Eve, who continues to have transfer rights to that NFT from Alice\u2019s vault, can steal that NFT and transfer to anyone",
            "[PoC-2](https://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L489-L522):",
            "* Alice grants Eve approval to transfer a particular NFT out of its vault using `approveTransferERC721()`",
            "* Alice learns that Eve\u2019s keys are compromises or that Eve is malicious and wants to revoke the approval but there is no mechanism to do so",
            "* Eve (or whoever stole her credentials) has transfer rights to that NFT from Alice\u2019s vault and can steal that NFT and transfer to anyone",
            "Recommend adding a boolean parameter to `approveTransferERC721()` and set the `nftApprovals`  to that parameter which can be true for giving approval and false for removing/revoking approval",
            "If ```msg.sender != _getOwner()```, call `approveTransferERC721()` with the boolean false to remove approval before making a transfer in `transferERC721()` on L515.",
            "**[xyz-ctrl (Visor) commented](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/34#issuecomment-862438325):**",
            "> duplicate",
            "> https://github.com/code-423n4/2021-05-visorfinance-findings/issues/35",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/34#issuecomment-873475636):**",
            "> #35 is about token being stuck in the vault. This issue is about not being able to revoke approval. Marking this as separate.",
            "**[ztcrypto (Visor) patched](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/34#issuecomment-889187960):**",
            " > patch [link](https://github.com/VisorFinance/visor-core/commit/71797204108fee8375bfb99a435c0e379bbcbd84#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)"
        ],
        "Approval for NFT transfers is not removed after transfer": [
            "_Submitted by cmichel, also found by gpersoon, and pauliax_",
            "The `Visor.transferERC721` does not reset the approval for the NFT.",
            "An approved delegatee can move the NFT out of the contract once.",
            "It could be moved to a market and bought by someone else who then deposits it again to the same vault.",
            "The first delegatee can steal the NFT and move it out of the contract a second time.",
            "Recommend resetting the approval on transfer.",
            "**[xyz-ctrl (Visor) confirmed](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/48#issuecomment-856953219):**",
            "> We will be mitigating this issue for our next release and before these experimental features are introduced in platform.",
            "> PR pending",
            "**[ztcrypto (Visor) commented](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/48#issuecomment-889192312):**",
            "> duplicate of above ones and fixed"
        ],
        "Unbounded loop in `_removeNft` could lead to a griefing/DOS attack": [
            "_Submitted by shw, also found by cmichel, gpersoon, pauliax, Sherlock, and toastedsteaksandwhich_",
            "Griefing/DOS attack is possible when a malicious NFT contract sends many NFTs to the vault, which could cause excessive gas consumed and even transactions reverted when other users are trying to unlock or transfer NFTs.",
            "The function `_removeNft` uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas.",
            "The function `onERC721Received` is permission-less. The vault accepts any NFTs from any NFT contract and pushes the received NFT into the array nfts.",
            "A malicious user could write an NFT contract, which calls `onERC721Received` of the vault many times to make the array nfts grow to a large size. Besides, the malicious NFT contract reverts when anyone tries to transfer (e.g., `safeTransferFrom`) its NFT.",
            "The vault then has no way to remove the transferred NFT from the malicious NFT contract. The two only functions to remove NFTs, `transferERC721` and `timeUnlockERC721`, fail since the malicious NFT contract reverts all `safeTransferFrom` calls.",
            "As a result, benign users who unlock or transfer NFTs would suffer from large and unnecessary gas consumption. The consumed gas could even exceed the block gas limit and cause the transaction to fail every time.",
            "Recommend using a mapping (e.g., `mapping(address=>Nft[]) nfts`) to store the received NFTs into separate arrays according to `nftContract` instead of putting them into the same one. Or, add a method specifically for the owner to remove NFTs from the nfts array directly.",
            "**[xyz-ctrl (Visor) confirmed](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-856368771):**",
            "> sponsor confirmed",
            "> We are working to mitigate this issue in our next upgrade",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-873481532):**",
            ">I\u2019m making this high severity because it doesn\u2019t need a malicious actor to happen. This can happen by simply being very successful",
            "**[xyz-ctrl (Visor) commented](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-856368771):**",
            ">  Agreed. We merged a pr with mitigations a few weeks ago here [VisorFinance/visor-core#2](https://github.com/VisorFinance/visor-core/pull/2)",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-873524863):**",
            "> Duplicate of [#66](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/66)",
            "**[ztcrypto (Visor) patched](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-889198308):**",
            "> duplicated and patched",
            "> [link](https://github.com/VisorFinance/visor-core/commit/585bedc435c297af5c91be7f525acf0832885a09#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)"
        ]
    },
    "MediumRiskFindings": {
        "Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients": [
            "_Submitted by 0xRajeev, also found by Sherlock, pauliax, shw, and JMukesh_",
            "ERC20 implementations are not always consistent. Some implementations of `transfer`\u00a0and `transferFrom` could return \u2018false\u2019 on failure instead of reverting. It is safer to wrap such calls into\u00a0`require()`\u00a0statements or use safe wrapper functions implementing return value/data checks to handle these failures. For reference, see similar Medium-severity finding from [Consensys Diligence Audit of Aave Protocol V2](https://consensys.net/diligence/audits/2020/09/aave-protocol-v2/#unhandled-return-values-of-transfer-and-transferfrom).",
            "While the contract uses Uniswap\u2019s `TransferHelper` library function `safeTransfer` in other places for ERC20 tokens, or OpenZeppelin\u2019s `saferTransferFrom` for ERC721 tokens (both of which call the token\u2019s `transfer`/`transferFrom` functions and check return value for success and return data), it misses using `TransferHelper.safeTransferFrom` in this one case on L610 in `timeLockERC20()` when tokens are transferred from owner to the vault and instead directly uses the token\u2019s `transferFrom()` call without checking for its return value.",
            "The impact can be that for an arbitrary ERC20 token, this `transferFrom()` call may return failure but the vault logic misses that, assumes it was successfully transferred into the vault and updates the `timelockERC20Balances` accounting accordingly. The `timeUnlockERC20()`, `transferERC20()` or `delegatedTransferERC20()` calls for that token will fail because the vault contract balance would have less tokens than accounted for in `timelockERC20Balances` because of the previously failed (but ignored) `transferFrom()` call.",
            "1. Let\u2019s say Alice owes Bob 100 USD after a week, for which they agree that Alice will pay in 100 tokens of USD stablecoin tokenA.",
            "2. Alice, the vault owner, calls `timeLockERC20()` for recipient=Bob, token=tokenA, amount=100 and expiry=1-week-from-then (corresponding Unix timestamp) but tokenA\u2019s implementation does not revert on failure but instead returns true/false. If the `transferFrom` failed, say because Alice did not have those 100 tokenAs, the return value is ignored on L610 in `timeLockERC20()` and vault logic considers that it indeed has 100 tokenAs locked for Bob.",
            "3. Bob looks at the `TimeLockERC20` event emitted in the successful `timeLockERC20()` transaction from Alice and assumes 100 tokenAs are indeed locked by Alice in the vault for him which can be withdrawn after expiry.",
            "4. After timelock expiry, Bob tries to transfer the 100 tokenAs Alice locked in the vault for him. The `TransferHelper`.`safeTransfer()` call on L637 in `timeUnlockERC20()` fails because the vault has 0 tokenAs because they were never successfully transferred in Step 2.",
            "5. Bob could thus be tricked into thinking that 100 tokenAs are locked in the vault for him by Alice but they never were. This leads to loss of funds for Bob.",
            "Recommend replacing use of",
            "```solidity",
            "IERC20(token).transferFrom(msg.sender, address(this), amount);",
            "```",
            "with",
            "```solidity",
            "TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);",
            "```",
            "This will revert on transfer failure for e.g. if `msg.sender` does not have a token balance >= amount.",
            "**[xyz-ctrl (Visor) acknowledged](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/39#issuecomment-862446159):**",
            "> sponsor acknowledged",
            "> disagree with severity 0",
            "> While we may include refactor in next version, this is all foreseen behavior and is component of many stable ethereum project.",
            "> The onus here is on client",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/39#issuecomment-873477796):**",
            "> I\u2019m going to make it medium as the risk is there but it could be mitigated by UI and tokens that are used.",
            "**[ztcrypto (Visor) patched](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/39#issuecomment-889172980):**",
            "> fixed patch [link](https://github.com/VisorFinance/visor-core/commit/71797204108fee8375bfb99a435c0e379bbcbd84#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)"
        ],
        "`transferERC721` doesn't clean `timelockERC721s`": [
            "_Submitted by gpersoon, also found by shw_",
            "The function `transferERC721` works similar to the functions `timeUnlockERC721` with timelocked NFT's.",
            "However `timeUnlockERC721` cleans `timelockERC721s` (delete `timelockERC721s[key]`;), while `transferERC721` doesn't clean `timelockERC721s`",
            "This could mean that timelock keys could be used later on (when the NFT would have been transferred to the contract on a later moment in time). Also, the administration doesn't correspond to the available NFT's. Additionally doing a delete gives backs some gas (at least for now).",
            "See [Issue #19](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/19) for code referenced in proof of concept",
            "Recommend checking if the `timelockERC721s` mapping should also be cleaned from `transferERC721`, if so adapt the code accordingly.",
            "**[xyz-ctrl (Visor) confirmed](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/19#issuecomment-862433933):**",
            "**[ztcrypto (Visor) patched](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/19#issuecomment-889177823):**",
            " > patch [link](https://github.com/VisorFinance/visor-core/commit/cc22d6e450e16aaa9eb3af1ee4d9e6ac8afe43da#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)"
        ],
        "`timelockERC721Keys` could exceed the block size limit": [
            "_Submitted by Sherlock, also found by shw_",
            "On line 504 of `Visor.sol`, looping through the `timelockERC721Keys` could exceed the block size limit",
            "Recommend transfer by index instead of token ID",
            "**[xyz-ctrl (Visor) acknowledged](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/65#issuecomment-862604018):**",
            "> sponsor acknowledged",
            "> We will be significantly refactoring experimental nft functionality in our next version before exposing to users of platform.",
            "> In this refactor we will cap size of nft collection",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/65#issuecomment-873558427):**",
            "> I\u2019m going to bump it to medium severity because this may happen if project is very successful",
            "**[ztcrypto (Visor) patched](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/65#issuecomment-889198875):**",
            "> patch [link](https://github.com/VisorFinance/visor-core/commit/585bedc435c297af5c91be7f525acf0832885a09#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)",
            ">",
            "> By using EnumerableSets"
        ]
    }
}