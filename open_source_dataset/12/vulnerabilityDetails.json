{
    "HighRiskFindings": {
        "Duplication of Balance": [
            "It is possible to duplicate currently held `ink` or `art` within a Cauldron, thereby breaking the contract's accounting system and minting units out of thin air.",
            "The `stir` function of the `Cauldron`, which can be invoked via a `Ladle` operation, caches balances in memory before decrementing and incrementing. As a result, if a transfer to self is performed, the assignment `balances[to] = balancesTo` will contain the added-to balance instead of the neutral balance.",
            "This allows one to duplicate any number of `ink` or `art` units at will, thereby severely affecting the protocol's integrity. A similar attack was exploited in the third bZx hack resulting in a roughly 8 million loss.",
            "Recommend that a `require` check should be imposed prohibiting the `from` and `to` variables to be equivalent.",
            "**[albertocuestacanada (Yield) confirmed](https://github.com/code-423n4/2021-05-yield-findings/issues/16#issuecomment-852044133):**",
            " > It is a good finding and a scary one. It will be fixed. Duplicated with #7."
        ],
        "auth collision possible": [
            "The auth mechanism of `AccessControl.sol` uses function selectors `(msg.sig)` as a `(unique)` role definition. Also the `_moduleCall` allows the code to be extended.",
            "Suppose an attacker wants to add the innocent-looking function \"`left_branch_block(uint32)` \"in a new module. Suppose this module is added via `_moduleCall`, and the attacker gets authorization for the innocent function.",
            "This function happens to have a signature of 0x00000000, which is equal to the root authorization. In this way, the attacker could get authorization for the entire project.",
            "Note: it's pretty straightforward to generate function names for any signature value; you can just brute force it because it's only 4 bytes.",
            "Recommend not allowing third parties to define or suggest new modules and double-checking the function signatures of new functions of a new module for collisions.",
            "**[albertocuestacanada (Yield) confirmed](https://github.com/code-423n4/2021-05-yield-findings/issues/5#issuecomment-852035261):**",
            " > The execution of any `auth` function will only happen after a governance process or by a contract that has gone through a thorough review and governance process.",
            ">",
            "> We are aware that new modules can have complete control of the Ladle, and for that reason, the addition of new modules would be subject to the highest level of scrutiny. Checking for signature collisions is a good item to add to that process.",
            ">",
            "> In addition to that, I would implement two changes in `AccessControl.sol` so that giving ROOT access is explicit.",
            "```solidity",
            "    function grantRole(bytes4 role, address account) external virtual admin(role) {",
            "        require(role != ROOT, \"Not ROOT role\");",
            "        _grantRole(role, account);",
            "    }",
            ">",
            "    function grantRoot(address account) external virtual admin(ROOT) {",
            "        _grantRole(ROOT, account);",
            "    }",
            "```",
            "> However, given that this could be exploited only through a malicious governance exploit, I would reduce the risk to \"Low.\"",
            "**[albertocuestacanada (Yield) acknowledged](https://github.com/code-423n4/2021-05-yield-findings/issues/5#issuecomment-864995915):**",
            " > After further thinking, instead of preventing auth collisions in the smart contracts, we will add CI checks for this specific issue instead."
        ],
        "YieldMath.sol / Log2: >= or > ?": [
            "The V1 version of `YieldMath.sol` contains \">=\" (larger or equal), while the V2 version of `YieldMath.sol` contains \">\" (larger) in the log_2 function.",
            "This change doesn't seem logical and might lead to miss calculations.",
            "The difference is present in several adjacent lines.",
            "```solidity",
            "function log_2 (uint128 x)",
            "...",
            "b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}",
            "```",
            "and",
            "```solidity",
            "function log_2(uint128 x)",
            "...",
            "b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}",
            "```",
            "Recommend checking which version is the correct version and fix the incorrect version.",
            "**[albertocuestacanada (Yield) confirmed](https://github.com/code-423n4/2021-05-yield-findings/issues/2#issuecomment-852039365):**",
            " > That's entirely my fault, and this is a scary one. We might be having a slightly different or impredictable curve in Pool.sol, and we might notice only after a long while with the Pools being slowly drained. We might never even have found this was the issue.",
            ">",
            "> I would suggest increasing the severity of this issue to High.",
            "**[albertocuestacanada (Yield) Resolved](https://github.com/code-423n4/2021-05-yield-findings/issues/2#issuecomment-854621275):**",
            " > [Fix](https://github.com/yieldprotocol/yieldspace-v2/pull/108)"
        ]
    },
    "MediumRiskFindings": {
        "Potential griefing with DoS by front-running vault creation with same `vaultID`": [
            "The `vaultID` for a new vault being built is required to be specified by the user building a vault via the `build()` function (instead of being assigned by the Cauldron/protocol). An attacker can observe a `build()` as part of a batch transaction in the mempool, identify the `vaultID` being requested, and front-run that by constructing a malicious batch transaction with only the build operation with that same `vaultID`. The protocol would create a vault with that `vaultID` and assign the attacker as its owner. More importantly, the valid batch transaction in the mempool, which was front-run, will later fail to create its vault because that `vaultID` already exists, as per the check on Line180 of `Cauldron.sol`. As a result, the valid batch transaction fails entirely because of the attacker front-running with the observed `vaultID`.",
            "While the attacker gains nothing except the ownership of an empty vault after spending the gas, this could grief the protocol's real users by preventing them from opening a vault and interacting with the protocol in any manner.",
            "The rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because valid vaults from the Yield front-end will never be successfully created and will lead to a DoS against the entire protocol's functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.",
            "Alice uses Yield's front-end to create a valid batch transaction. Evil Eve observes that in the mempool and identifies the `vaultID` of the vault being built by Alice. Eve submits her own batch transaction (without using the front-end) with only a build operation using Alice's `vaultID`. She uses a higher gas price to front-run Alice's transaction and get's the protocol to assign that `vaultID` to herself. Alice's batch transaction later fails because the `vaultID` she requested is already assigned to Eve. Eve can do this for any valid transaction to grief protocol users by wasting her gas to cause DoS.",
            "Recommend mitigating this DoS vector by having the `Cauldron` assign the `vaultID` instead of the user specifying it in the `build()` operation. This would likely require the `build()` to be a separate non-batch transaction followed by other operations that use the `vaultID` assigned in `build()`. Consider the pros/cons of this approach because it will significantly affect the batching/caching logic in `Ladle`.",
            "Alternatively, consider adding validation logic in `Ladle's` batching to revert batches that have only build or a subset of the operations that do not make sense to the protocol's operations per valid recipes, which could be an attacker's signature pattern.",
            "**[albertocuestacanada (Yield) confirmed](https://github.com/code-423n4/2021-05-yield-findings/issues/43#issuecomment-853368593):**",
            " > Good find. [Fix](https://github.com/yieldprotocol/vault-v2/pull/210)"
        ],
        "Uniswap Oracle uses wrong prices": [
            "The Uniswap oracle uses a mock contract with hard-coded prices to retrieve the price, which is not feasible in production. Also, note that even when using the \"real deal\" `@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol`... it does not, in fact, return the prices.",
            "The price could change from the set price. Meanwhile, always updating new prices with `set` will be too slow and gas expensive.",
            "Recommend using `cumulativeTicks = pool.observe([secondsAgo, 0]) // [a_t1, a_t2]` and applying [equation 5.5](https://uniswap.org/whitepaper-v3.pdf) from the Uniswap V3 whitepaper to compute the token0 TWAP.",
            "Note that even the [official `.consult` call](https://github.com/Uniswap/uniswap-v3-periphery/blob/b55e7e81a803082c0328e2826592327da373ab00/contracts/libraries/OracleLibrary.sol#L27) seems to only return the averaged cumulative ticks; you'd still need to compute the `1.0001^timeWeightedAverageTick` in the function.",
            "**[albertocuestacanada (Yield) acknowledged](https://github.com/code-423n4/2021-05-yield-findings/issues/26#issuecomment-852872017):**",
            " > We probably should have not included this contract; it's too confusing since, at the time, the Uniswap v3 OracleLibrary was still a mock, and this hasn't gone real testing.",
            ">",
            "> The price source in a production version would be a Uniswap v3 pool, not one of our mock oracle sources. We never expected to call `set` in production, but to retrieve the prices from a Uniswap v3 pool using the mentioned library (which was not even merged into main at the start of the contest).",
            ">",
            "> We will check with the Uniswap team what is the recommended way of using their oracles. The equation 5.5 in the whitepaper is problematic because an exponentiation of two fractional numbers in Solidity is neither trivial nor cheap. Our understanding is that one of the goals of the OracleLibrary was to provide a consistent implementation to this formula.",
            ">",
            "> From a conversation with @moodysalem, I understand that the code in `getQuoteAtTick` might achieve the same result as the 5.5 equation, so maybe we need to retrieve the average tick with `consult`, and then the actual price with `getQuoteAtTick`.",
            "**[albertocuestacanada (Yield) commented](https://github.com/code-423n4/2021-05-yield-findings/issues/26#issuecomment-852872737):**",
            " > I'm using the `acknowledged` label for findings that require further investigation to assess."
        ],
        "Witch can't give back vault after 2x grab": [
            "The `witch.sol` contract gets access to a vault via the grab function in case of liquidation. If the `witch.sol` contract can't sell the debt within a certain amount of time, a second grab can occur.",
            "After the second grab, the information of the original owner of the vault is lost, and the vault can't be returned to the original owner once the debt has been sold.",
            "The `grab` function stores the previous owner in `vaultOwners[vaultId]`, and then the contract itself is the new owner (via `cauldron.grab` and `cauldron._give`).",
            "The `vaultOwners[vaultId]` is overwritten at the second grab",
            "The function buy of `Witch`.sol tried to give the vault back to the original owner, which won't succeed after a second grab. [See the issue page for proof of concept and referenced code](https://github.com/code-423n4/2021-05-yield-findings/issues/8)",
            "Assuming it's useful to give back the vault to the original owner,  recommend making a stack/array of previous owners if multiple instances of the `witch.sol` contract would be used. Or, check if the witch is already the owner (in the `grab` function) and keep the` vaultOwners[vaultId]` if that is the case.",
            "**[albertocuestacanada (Yield) confirmed](https://github.com/code-423n4/2021-05-yield-findings/issues/8#issuecomment-852009841):**",
            " > This is a good finding and a vulnerability that we will fix. I anticipate that we will store the original owner in `Cauldron.auctions` along with the time at which the auction was started.",
            "**[albertocuestacanada (Yield) commented](https://github.com/code-423n4/2021-05-yield-findings/issues/8#issuecomment-853405752):**",
            " > Actually, we might remove some overengineering by taking out the feature of allowing multiple competing liquidation engines.",
            ">",
            "> That would allow us to:",
            "> 1. Move the `auctions` mapping to the `Witch.`",
            "> 2. Remove the `auctionInterval` setting",
            "> 3. Simplify `grab`",
            "> 3. Stop worrying about more than one `grab.`",
            "**Editors note:** An alternative submission for this bug was not included in this report but can be found in [Issue #30](https://github.com/code-423n4/2021-05-yield-findings/issues/30)."
        ],
        "User can redeem more tokens by artificially increasing the chi accrual": [
            "A user can artificially increase the chi accrual (after maturity) by flash borrow on Compound, which affects the exchange rate used by the chi oracle. As a result, the user redeems more underlying tokens with the same amount of fyTokens since the accrual is larger than before.",
            "The `exchangeRateStored` used by chi oracle is calculated based on the `totalBorrows` of `CToken`, which can be artificially increased by a large amount of borrow operated on Compound. Consider a user performing the following steps in a single transaction (assuming that the fyToken is matured):",
            "1. Deposits a large amount of collateral (whether from flash loans or not) and borrow from Compound",
            "2. Burns his fyToken by calling `redeem.`",
            "3. Repays the borrow to Compound",
            "The user only needs to pay for the gas fees of borrowing and repaying (since they happen in the same transaction) but can redeem more underlying tokens than a regular redeem.",
            "Referenced code:",
            "[CompoundMultiOracle.sol#L46](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/oracles/compound/CompoundMultiOracle.sol#L46)",
            "[FYToken.sol#L125](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L125)",
            "[FYToken.sol#L132-L143](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L132-L143)",
            "Recommend making the chi accrual time-weighted to mitigate the manipulation caused by flash borrow and repay.",
            "**[albertocuestacanada (Yield) acknowledged](https://github.com/code-423n4/2021-05-yield-findings/issues/69#issuecomment-854498235):**",
            " > If this is true, that means that we don't understand how `exchangeRateStored` works (quite likely).",
            ">",
            "> Our understanding was that `exchangeRateStored` is an increasing accumulator, same as `chi` in MakerDAO, which is both an exchange rate and an accumulator.",
            ">",
            "> If `exchangeRateStored` can go down in value, as well as up, we might have to revisit how we source it."
        ],
        "Uninitialized or Incorrectly set `auctionInterval` may lead to liquidation engine livelock": [
            "The `grab()` function in Cauldron is used by the Witch or other liquidation engines to grab vaults that are under-collateralized. To prevent re-grabbing without sufficient time for auctioning collateral/debt, the logic uses an `auctionInterval` threshold to give a reasonable window to a liquidation engine that has grabbed the vault.",
            "The `grab()` function has a comment on Line 354: \"// Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\" indicating a requirement of the `auctionInterval` being equal to one day. This can happen only if the `auctionInterval` is set appropriately. However, this state variable is uninitialized (defaults to 0) and depends on `setAuctionInterval()` being called with the appropriate `auctionInterval_` value, which is also not validated.",
            "Discussion with the project lead indicated that this comment is incorrect. Nevertheless, it is safer to initialize `auctionInterval` at declaration to a safe default value instead of the current 0, which will allow liquidation engines to re-grab vaults without making any progress on liquidation auction. It is also good to add a threshold check-in `setAuctionInterval()` to ensure the new value meets/exceeds a reasonable default value.",
            "The rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because liquidation engines will keep re-grabbing vaults from each other and potentially result in liquidation bots entering a live-lock situation without making any progress on liquidation auctions. This will result in collateral being stuck and impact the entire protocol's functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.",
            "See [Issue page](https://github.com/code-423n4/2021-05-yield-findings/issues/44) for proof of concept and referenced code.",
            "Recommend:",
            "1. Initialize `auctionInterval`  at declaration with a reasonable default value.",
            "2. Add a threshold check in `setAuctionInterval()` to ensure the new value meets/exceeds a reasonable default value.",
            "**[albertocuestacanada (Yield) confirmed but disagreed with severity](https://github.com/code-423n4/2021-05-yield-findings/issues/44#issuecomment-853373915):**",
            " > While we support multiple liquidation engines, we are going live with only one, and only one is in the scope of the contest.",
            ">",
            "> Zero is an acceptable value for `auctionInterval` using just one liquidation engine (the Witch). The issue can be solved with better natspec and better documentation; therefore, a severity of 0 is suggested.",
            "**[albertocuestacanada (Yield) commented](https://github.com/code-423n4/2021-05-yield-findings/issues/44#issuecomment-853494087):**",
            " > Actually, if we forget to set `auctionInterval` to a reasonable value, an attacker could repeatedly call `grab` with just one Witch, stopping auctions from dropping down in price until an emergency governance action is taken.",
            ">",
            "> Therefore, I would suggest the severity be reduced to 1 instead of zero."
        ],
        "Violation of implicit constraints in batched operations may break protocol assumptions": [
            "The Ladle batching of operations is a complex task (as noted by the project lead) with implicit constraints on what operations can be bundled together in a batch. Operations can/have to appear how many times and in what order/sequence etc. Some examples of these constraints are: `Join Ether` should be the first operation, `Exit Ether` the last, and only one `Join Ether` per batch.",
            "All this complexity is managed currently by anticipating all interactions to happen via their authorized front-end, which uses validated (and currently only revealed on-demand) recipes that adhere to these constraints. There is a plan to open the design up to other front-ends and partner integrating protocols that will also test their batch recipes or integrations for these constraints.",
            "Breaking some of these constraints opens up the protocol to failing transactions, undefined behavior, or potentially loss/lock of funds. Defensive programming suggests enforcing such batch operation constraints in the code and documentation and onboarding checks for defense-in-depth. Relying on documentation or external validation may not be sufficient for arguably the most critical aspect of batched operations which is the only authorized way to interact with the protocol.",
            "The rationale for assigning medium-severity is that, while the likelihood of this may be low because of controlled/validated onboarding on new front-ends or integrating protocols, the impact of accidental deviation from implicit constraints is high. This may result in a transaction failing, or tokens getting locked/lost, thus impact the entire protocol's functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.",
            "1. A new front-end project comes up claiming to provide a better user interface than the project's authorized front-end. It does not use the recipe book (correctly) and makes Ladle batches with incorrect operations, thus failing the constraints and leading to protocol failures and token lock/loss.",
            "2. An integrating protocol goes through the approved onboarding and validation but has missed bugs in its recipe for batches, thus failing the constraints and leading to protocol failures and token lock/loss.",
            "Recommend enforcing batch operation constraints explicitly in the code (e.g., with tracking counters/booleans for operations) along with documentation and onboarding validation. This may increase the complexity of the batching code but adds fail-safe defense-in-depth for any mistakes in onboarding validation of implicit constraints, which may affect protocol operations significantly.",
            "**[albertocuestacanada (Yield) disputed](https://github.com/code-423n4/2021-05-yield-findings/issues/45#issuecomment-853371363):**",
            " > I don't think implementing the suggested checks is worth the added complexity and deployment gas.",
            ">",
            "> Given that this is an issue disclosed by the sponsor and widely discussed, I would find it unfair to the other wardens if accepted.",
            "**[dmvt (Judge) commented](https://github.com/code-423n4/2021-05-yield-findings/issues/45#issuecomment-860962920):**",
            " > The warden brings up a valid concern. As to the sponsor's objection, the sponsor has written, \"The Ladle is a complex contract, with wide-ranging powers over the protocol. **It is the riskiest contract, and at the same time, the one that has more room for a bug to hide. It is of the highest importance to find as many bugs as we can in it.**\" (emphasis mine). I highly recommend the issue be addressed by the sponsor.",
            "**[albertocuestacanada (Yield) commented](https://github.com/code-423n4/2021-05-yield-findings/issues/45#issuecomment-862419851):**",
            " > I still disagree. I disclosed this issue myself first in the C4 discord, and it is a design choice.",
            ">",
            "> Users are not expected to build batches themselves and won't be provided with any tools to do so. If a user decides to ignore all advice and go to the extreme length of interacting with the smart contracts himself or via an unauthorized front-end, it's completely on him if he loses funds.",
            ">",
            "> It is impossible that a user will execute a non-reverting batch without careful research on the batching system. To do that, he would need to exactly match one or more action codes with abi-encoded arrays of parameters of the right types.",
            ">",
            "> My concerns on the batching system are not on users or integrators building a bad batch and losing their funds.",
            ">",
            "> My concerns are that the batching system is complex, and there could be the chance that a batch could be built with a negative effect on the protocol or for other users. Since the Ladle has sweeping powers over the protocol, that would be a real issue. Such a batch has not been found.",
            ">",
            "> So, to reiterate. The issue being brought up was brought up in the discord by myself, and it is a conscious trade-off we made of usability for flexibility. No undisclosed issue has been found."
        ],
        "Possible DoS attack when creating `Joins` in `Wand`": [
            "It is possible for an attacker to intendedly create a fake `Join` corresponding to a specific token beforehand to make `Wand` unable to deploy the actual `Join`, causing a DoS attack.",
            "The address of `Join` corresponding to an underlying `asset` is determined as follows and thus unique:",
            "```solidity",
            "Join join = new Join{salt: keccak256(abi.encodePacked(asset))}();",
            "```",
            "Besides, the function `createJoin` in the contract `JoinFactory` is permissionless: Anyone can create the `Join` corresponding to the `asset`. An attacker could then deploy many `Joins` with different common underlying assets (e.g., DAI, USDC, ETH) before the `Wand` deploying them. The attempt of deploying these `Joins` by `Wand` would fail since the attacker had occupied the desired addresses with fake `Joins`, resulting in a DoS attack.",
            "Moreover, the attacker can also perform DoS attacks on newly added assets: He monitors the mempool to find transactions calling the function `addAsset` of `Wand` and front-runs them to create the corresponding `Join` to make the benign transaction fail.",
            "Referenced code:",
            "[JoinFactory.sol#L64-L75](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol#L64-L75)",
            "[Wand.sol#L53](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L53)",
            "Recommend enabling access control in `createJoin` (e.g., adding the `auth` modifier) and allowing `Wand` to call it.",
            "**[albertocuestacanada (Yield) confirmed](https://github.com/code-423n4/2021-05-yield-findings/issues/70#issuecomment-854503335):**",
            " > The issue exists, and we appreciate raising it.",
            ">",
            "> The solution can't be adding `auth` to `createJoin`, since anyone can use CREATE2 to deploy a Join with their own factory, but with our Join bytecode, occupying the same address we would.",
            ">",
            "> The proper mitigation, in our opinion, is to ditch CREATE2 and deploy Joins using CREATE instead.",
            ">",
            "> As for the risk, such a DoS attack wouldn't cause a loss of funds or an interruption on user service. It would cause a governance action to revert, which would be quickly fixed by deploying a new JoinFactory and replacing the Wand. Fortunately, no contract uses the Wand as a Join registry (maybe we should!).",
            ">",
            "> I suggest the risk is downgraded to 1."
        ],
        "Users can avoid paying borrowing interest after the fyToken matures": [
            "According to the protocol design, users have to pay borrowing interest when repaying the debt with underlying tokens after maturity. However, a user can give his vault to `Witch` and then buy all his collateral using underlying tokens to avoid paying the interest. Besides, this bug could make users less incentivized to repay the debt before maturity and hold the underlying tokens until liquidation.",
            "1. A user creates a new vault and opens a borrowing position as usual.",
            "2. The maturity date passed. If the user wants to close the position using underlying tokens, he has to pay a borrowing interest (line 350 in `Ladle`), which is his debt multiplied by the rate accrual (line 373).",
            "3. Now, the user wants to avoid paying the borrowing interest. He gives his vault to `Witch` by calling the function `batch` of `Ladle` with the operation `GIVE`.",
            "4. He then calls the function `buy` of `Witch` with the corresponding `vaultId` to buy all his collateral using underlying tokens.",
            "In the last step, the `elapsed` time (line 61) is equal to the current timestamp since the vault is never grabbed by `Witch` before, and thus the auction time of the vault, `cauldron.auctions(vaultId)`, is 0 (the default mapping value). Therefore, the collateral is sold at a price of `balances_.art/balances_.ink` (line 74). The user can buy `balances_.ink` amount of collateral using `balances_.art` but not paying for borrowing fees.",
            "Recommend not allowing users to `give` vaults to `Witch`. And to be more careful, requiring `vaultOwners[vaultId]` and `cauldron.auctions(vaultId)` to be non-zero at the beginning of function `buy`.",
            "**[albertocuestacanada (Yield) confirmed](https://github.com/code-423n4/2021-05-yield-findings/issues/71#issuecomment-856589289):**",
            " > That's a good catch. The mitigation steps are right to avoid this being exploited by malicious users, but it would be better to fix the underlying issue.",
            ">",
            "> The problem is that the Witch always applies a 1:1 exchange rate between underlying and fyToken, which is not true after maturity. As long as this is not fixed, the protocol will lose money after maturity liquidations.",
            "**[albertocuestacanada (Yield) commented](https://github.com/code-423n4/2021-05-yield-findings/issues/71#issuecomment-856599112):**",
            " > More specifically, `_debtInBase` should be a Cauldron public function, and return (debtInFYToken, debtInBase). The Ladle would save a bit in deployment gas; the Witch would use it to determine the underlying / fyToken exchange rate.",
            "**[albertocuestacanada (Yield) commented](https://github.com/code-423n4/2021-05-yield-findings/issues/71#issuecomment-856614042):**",
            " > However, since `grab` wouldn't be called on the Witch, the vault owner wouldn't be registered. With the liquidation being a Dutch auction, the vault owner would only get a portion of his collateral back after paying all the debt. The vault with the remaining collateral would be given to address(0).",
            ">",
            "> There is a small protocol loss from miscalculated vault debt on vaults liquidated after maturity, but no user funds would be at risk.",
            ">",
            "> I would propose a severity of 2, given there are monetary losses, however slight, to the protocol. The attack described can't happen, but it revealed a real issue."
        ],
        "auth only works well with external functions": [
            "<!-- appended to end of section -->",
            "The auth modifier of `AccessControl.sol` doesn't work as you would expect.",
            "It checks if you are authorized for `msg.sig`. However, `msg.sig` is the signature of the first function you have called (not the current function). So, if you call function A, which calls function B, the \"auth\" modifier of function B checks if you are authorized for function A!",
            "There is a difference between external and public functions. For external functions, this works as expected because a fresh call (with a new `msg.sig`) is always made.",
            "However, with public functions called from within the same contract, this doesn't happen as the problem described above occurs.",
            "See the issue page for proof of concept, which shows the problem. In the code, several functions have `public` and `auth` combined; see also in the proof of concept.",
            "In the current codebase, I couldn't find a problem situation; however, this could be accidentally introduced with future changes.",
            "It could also be introduced via the `_moduleCall` of Ladle.sol, which allows functions to be defined which might call the public functions.",
            "See [issue #4 page](https://github.com/code-423n4/2021-05-yield-findings/issues/69#issuecomment-854498235) for proof of concept and a list of occurrences of public auth.",
            "Recommend making sure all auth functions use external (still error-prone)",
            "Or, recommend changing the modifier to something like:",
            "```solidity",
            "modifier auth(bytes4 fs) {",
            "require (msg.sig == fs,\"Wrong selector\");",
            "require (_hasRole(msg.sig, msg.sender), \"Access denied\");",
            "_;",
            "}",
            "```",
            "```solidity",
            "function setFee(uint256) public auth(this.setFee.selector) {",
            "   .....",
            "}",
            "```",
            "**[albertocuestacanada (Yield) confirmed](https://github.com/code-423n4/2021-05-yield-findings/issues/4#issuecomment-852042973):**",
            " > While many governance functions have been marked `public` instead of `external` throughout the code, they are never called from any other function in the same contract, and they should never be.",
            ">",
            "> In all contracts of the protocol, `auth` functions are only called by other contracts or by EOAs, with the latter being governance actions.",
            ">",
            "> The suggestion of changing all `public auth` functions to `external auth` will be applied; however, no changes will be made to AccessControl.sol, and the suggested severity is 1."
        ]
    }
}