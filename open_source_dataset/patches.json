{
    "`SynthVault` withdraw forfeits rewards": {
        "desc": "The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards.\nThe `synthReward` variable in `_processWithdraw` is also never used - it was probably intended that this variable captures the claimed rewards.\nUsually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.",
        "patch": "function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {\n    require((block.timestamp > mapMember_depositTime[_member]), \"lockout\"); // Must not withdraw before lockup period passed\n    // First, calculate and assign the rewards\n    synthReward = calculateRewards(_member, _synth); // Assuming calculateRewards is a function that calculates rewards\n    // Then, calculate the principal amount to withdraw\n    uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Calc amount to withdraw\n    mapMemberSynth_deposit[_member][_synth] -= _principle; // Remove from user's recorded vault holdings\n    uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); // Calc SPARTA value of amount\n    mapMemberTotal_weight[_member] -= _weight; // Remove from member's total weight (scope: member)\n    mapMemberSynth_weight[_member][_synth] -= _weight; // Remove from member's synth weight (scope: member -> synth)\n    totalWeight -= _weight; // Remove from total weight (scope: vault)\n    emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);\n    return (_principle + synthReward); // Return the total of principle and synthReward\n}"
    },
    "`Pool.sol` & `Synth.sol`: Failing Max Value Allowance": {
        "desc": "In the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.\nThis also makes the comment `// No need to re-approve if already max` misleading, because the max allowance attainable is `type(uint256).max - 1`, and re-approval does happen in this case.\nThis affects the `approveAndCall` implementation since it uses `type(uint256).max` as the allowance amount, but the resulting allowance set is zero.",
        "patch": "function _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), \"sender\");\n    require(spender != address(0), \"spender\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n}"
    },
    "Result of `transfer` / `transferFrom` not checked": {
        "desc": "A call to `transferFrom` or `transfer` is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \"false\" is returned. It's important to check this. If you don't, you could mint tokens without have received sufficient tokens to do so and could loose funds. Its also a best practice to check this.",
        "patch": "function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n    bool transferSuccess = _transfer(sender, recipient, amount);\n    require(transferSuccess, \"Transfer failed\");\n    // Unlimited approval (saves an SSTORE)\n    if (_allowances[sender][msg.sender] < type(uint256).max) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"allowance err\");\n        _approve(sender, msg.sender, currentAllowance - amount);\n    }\n    return true;\n}"
    },
    "`SynthVault` rewards can be gamed": {
        "desc": "The `SynthVault._deposit` function adds `weight` for the user that depends on the spot value of the deposit synth amount in `BASE`.\nThis spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity.\nHowever, the reward (see `calcReward`) is measured in BASE tokens unrelated to the pool.\nTherefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:\n1. Manipulate the pool spot price of the `iSYNTH(_synth).LayerONE()` pool by dripping a lot of `BASE` into it repeatedly (sending lots of smaller trades is less costly due to the [path-independence of the continuous liquidity model](https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the `BASE` per `token` price.\n2. Call `SynthVault.depositForMember` and deposit a _small_ amount of synth token. The `iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)` will return an inflated weight due to the price.\n3. Optionally drip more `BASE` into the pool and repeat the deposits\n4. Drip back `token` to the pool to rebalance it\nThe user's `weight` is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.",
        "patch": "function _deposit(address _synth, address _member, uint256 _amount) internal {\n    if (!isStakedSynth[_synth]) {\n        isStakedSynth[_synth] = true; // Record as a staked synth\n        stakedSynthAssets.push(_synth); // Add to staked synth array\n    }\n    // Calculate the TWAP instead of using spot price directly\n    uint256 twapPrice = iUTILS(_DAO().UTILS()).calcTWAPValueInBase(_synth, _amount);\n    uint256 weight = calculateWeight(twapPrice, _amount);\n    updateMemberWeight(_member, _synth, weight);\n}"
    },
    "arbitrary synth mint/burn from pool": {
        "desc": "`Pool` can mint arbitrary `Synth` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.\n[Pool's mintSynth logic](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229-L242), [Synth's mintSynth logic], and [Synth's authorization logic].\nThe price of the synthetics to be mint is calculated in `Pool` based on the AMM price of the current Pool\nHere's a web3.py script of minting arbitrary `Synth` in a pool.\nFor simplicity, two pools are set with the assumption that link is 10x expensive than dai.\n```python\nsparta_amount = 100 * 10**18\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(link_pool.address, sparta_amount).transact({'from': user})\nlink_pool.functions.mintSynth(link_synth.address, user).transact({'from': user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\nprint('get link synth amount from link pool:', after_link_synth - initail_link_synth)\nsparta_amount = 100 * 10**18\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(dai_pool.address, sparta_amount).transact({'from': user})\ndai_pool.functions.mintSynth(link_synth.address, user).transact({'from': user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\nprint('get link synth amount from dai pool:', after_link_synth - initail_link_synth)\n```\nThe log of the above script\n```solidity\nget link synth amount from link pool: 97078046905036524413\nget link synth amount from dai pool: 970780469050365244136\n```",
        "patch": "function mintSynth(address synth, address member, uint amount) external onlyPool returns (uint syntheticAmount){\n    require(iSYNTH(synth).LayerONE() == TOKEN, \"invalid synth\"); // Check if the underlying token matches the expected TOKEN\n    uint lpUnits = _getAddedLPAmount(msg.sender); // Get the received LP units\n    mapSynth_LPDebt[msg.sender] += amount; // Increase debt by synth amount\n    mapSynth_LPBalance[msg.sender] += lpUnits; // Increase lp balance by LPs received\n    _mint(member, amount); // Mint the synths & tsf to user\n    return amount;\n}"
    },
    "Hijack token pool by burning liquidity token": {
        "desc": "`Pool` allows users to burn lp tokens without withdrawing the tokens. This allows the hacker to mutate the pools' rate to a point that no one can get any lp token anymore (even if depositing token).\nThe liquidity tokens are calculated at `Utils:calcLiquidityUnits`\n```solidity\n// units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n// P * (part1 + part2) / (part3) * slipAdjustment\nuint slipAdjustment = getSlipAdustment(b, B, t, T);\nuint part1 = t*(B);\nuint part2 = T*(b);\nuint part3 = T*(B)*(2);\nuint _units = (P * (part1 + (part2))) / (part3);\nreturn _units * slipAdjustment / one;  // Divide by 10**18\n```\nwhere `P` stands for `totalSupply` of current Pool. If `P` is too small (e.g, 1) then all the units would be rounding to 0.\nSince any person can create a `Pool` at `PoolFactory`, hackers can create a Pool and burn his lp and set `totalSupply` to 1. He will be the only person who owns the Pool's lp from now on. [Pool's burn logic] and [Utils' lp token formula].\nHere's a script of a user depositing 1M token to a pool where `totalSupply` equals 1\n```solidity\ndai_pool.functions.burn(init_amount-1).transact()\nprint('total supply', dai_pool.functions.totalSupply().call())\ndai.functions.transfer(dai_pool.address, 1000000 * 10**18).transact()\ndai_pool.functions.addForMember(user).transact()\nprint('lp received from depositing 1M dai: ', dai_pool.functions.balanceOf(user).call())\n```\nOutput:\n```solidity\ntotal supply 1\nlp received from depositing 1M dai:  0\n```",
        "patch": "function burn(uint256 amount) public virtual override {\n    require(msg.sender == owner, \"Only owner can burn tokens\");\n    _burn(msg.sender, amount);\n}"
    },
    "`LendingPair.liquidateAccount` does not accrue and update `cumulativeInterestRate`": {
        "desc": "The `LendingPair.liquidateAccount` function does not accrue and update the `cumulativeInterestRate` first, it only calls `_accrueAccountInterest` which does not update and instead uses the old `cumulativeInterestRate`.\nThe liquidatee (borrower)'s state will not be up-to-date.\nI could skip some interest payments by liquidating myself instead of repaying if I'm under-water.\nAs the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.",
        "patch": "function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    _accrueAccount(_account); // Updated function call\n    _accrueAccount(feeRecipient()); // Updated function call\n    uint health = accountHealth(_account);\n    require(health < controller.LIQ_MIN_HEALTH(), \"LendingPair: account health > LIQ_MIN_HEALTH\");\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, debtOf[_repayToken][_account]);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount);\n    uint callerFee    = supplyDebt * controller.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * controller.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupply(supplyToken, _account, supplyBurn);\n    _mintSupply(supplyToken, feeRecipient(), systemFee);\n    _burnDebt(_repayToken, _account, _repayAmount);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }"
    },
    "`LendingPair.liquidateAccount` fails if tokens are lent out": {
        "desc": "The `LendingPair.liquidateAccount` function tries to pay out underlying supply tokens to the liquidator using `_safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput)` but there's no reason why there should be enough `supplyOutput` amount in the contract, the contract only ensures `minReserve`.\nAs a result, no liquidations can be performed if all tokens are lent out.\n**Example:** User A supplies 1k\\$ WETH, User B supplies 1.5k\\$ DAI and borrows the ~1k\\$ WETH (only leaves `minReserve`). The ETH price drops but user B cannot be liquidated as there's not enough WETH in the pool anymore to pay out the liquidator.",
        "patch": "function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    _accrueAccount(_account); // Updated function call\n    _accrueAccount(feeRecipient()); // Updated function call\n    uint health = accountHealth(_account);\n    require(health < controller.LIQ_MIN_HEALTH(), \"LendingPair: account health > LIQ_MIN_HEALTH\");\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, debtOf[_repayToken][_account]);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount);\n    uint callerFee    = supplyDebt * controller.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * controller.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupply(supplyToken, _account, supplyBurn);\n    _mintSupply(supplyToken, feeRecipient(), systemFee);\n    _burnDebt(_repayToken, _account, _repayAmount);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }"
    },
    "UniswapConfig getters return wrong token config if token config does not exist": {
        "desc": "The `UniswapConfig.getTokenConfigBySymbolHash` function does not work as `getSymbolHashIndex` returns `0` if there is no config token for that symbol (uninitialized map value), but the outer function implements the non-existence check with `-1`.\nThe same issue occurs also for:\n- `getTokenConfigByCToken`\n- `getTokenConfigByUnderlying`\nWhen encountering a non-existent token config, it will always return the token config of the **first index** (index 0) which is a valid token config for a completely different token.\nThis leads to wrong oracle prices for the actual token which could in the worst case be used to borrow more tokens at a lower price or borrow more tokens by having a higher collateral value, essentially allowing undercollateralized loans that cannot be liquidated.",
        "patch": "function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\n    uint index = symbolHashIndex[symbolHash];\n    require(index != 0, \"Token config not found\");\n    return index;\n}\n\nfunction getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\n    uint index = getSymbolHashIndex(symbolHash);\n    return getTokenConfig(index);\n}\n\nfunction getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {\n    uint index = getCTokenIndex(cToken);\n    require(index != 0, \"Token config not found\");\n    return getTokenConfig(index);\n}\n\nfunction getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\n    uint index = getUnderlyingIndex(underlying);\n    require(index != 0, \"Token config not found\");\n    return getTokenConfig(index);\n}"
    },
    "IndexPool's `INIT_POOL_SUPPLY` is not fair.": {
        "desc": "#### Impact\nThe `indexPool` mint `INIT_POOL_SUPPLY` to address 0 in the constructor. However, the value of the burned lp is decided by the first lp provider. According to the formula in [`IndexPool.sol` L106].\n`AmountIn = first_lp_amount / INIT_POOL_SUPPLY` and the burned lp worth = `AmountIn * (INIT_POOL_SUPPLY) / (first_lp_amount + INIT_POOL_SUPPLY)`.\nIf a pool is not initialized with optimal parameters, it would be a great number of tokens been burn. All lp providers in the pool would receive less profit.\nThe optimal parameter is `10**8`. It's likely no one would initialize with `10**8` wei in most pools. I consider this is a high-risk issue.\n#### Proof of concept\nThere are two scenarios that the first lp provider can do. The lp provider provides the same amount of token in both cases. However, in the first scenario, he gets about `10 ** 18 * 10**18` lp while in the other scenario he gets `100 * 10**18` lp.\n```python\ndeposit_amount = 10**18\nbento.functions.transfer(link.address, admin, pool.address, deposit_amount).transact()\nbento.functions.transfer(dai.address, admin, pool.address, deposit_amount).transact()\npool.functions.mint(encode_abi(\n    ['address', 'uint256'],\n    [admin, 10**8] # minimum\n)).transact()\npool.functions.mint(encode_abi(\n    ['address', 'uint256'],\n    [admin, 10000000000009999 * 10** 20]\n)).transact()\n```\n```python\ndeposit_amount = 10**18\nbento.functions.transfer(link.address, admin, pool.address, deposit_amount).transact()\nbento.functions.transfer(dai.address, admin, pool.address, deposit_amount).transact()\npool.functions.mint(encode_abi(\n    ['address', 'uint256'],\n    [admin, deposit_amount * 100]\n)).transact()\n```\n####",
        "patch": "function mint(bytes calldata data) public override lock returns (uint256 liquidity) {\n        address recipient = abi.decode(data, (address));\n        (uint256 _reserve0, uint256 _reserve1) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 _totalSupply = totalSupply;\n        \n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);\n        uint256 newLiq = _computeLiquidity(balance0 - fee0, balance1 - fee1);\n        \n        // Determine an optimized parameter for the user\n        uint256 optimalParameter = determineOptimalParameter();\n        \n        if (_totalSupply == 0) {\n            liquidity = newLiq - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY);\n        } else {\n            // Adjust newLiq based on the optimized parameter\n            newLiq = newLiq * optimalParameter / 10**8; // Assuming 10^8 is the optimal parameter\n            \n            // Mint LP tokens to the recipient\n            _mint(recipient, newLiq);\n            liquidity = newLiq;\n        }\n}"
    },
    "Wrong trading pricing calculations": {
        "desc": "In the `Pricing` contract, an agent can manipulate the trading prices by spamming a high amount of trades.\nIndeed an agent can create a high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls `Trader.executeTrade`; now every order calls a `Pricing.recordTrade` using the arbitrary price set by the agent.\nSince the trades are all made in the same hour, by the way `hourlyTracerPrices[currentHour]` is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the `fundingRates` and the `fairPrice`, allowing a malicious agent the ability to manipulate the market.",
        "patch": "\nfunction recordTrade(uint256 tradePrice, uint256 fillAmount) external override onlyTracer {\n    uint256 currentOraclePrice = oracle.latestAnswer();\n    if (startLastHour <= block.timestamp - 1 hours) {\n        // emit the old hourly average\n        uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);\n        emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);\n\n        // update funding rate for the previous hour\n        updateFundingRate();\n\n        // update the time value\n        if (startLast24Hours <= block.timestamp - 24 hours) {\n            // Update the interest rate every 24 hours\n            updateTimeValue();\n            startLast24Hours = block.timestamp;\n        }\n\nfunction executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)\n    external\n    override\n{\n    require(makers.length == takers.length, \"TDR: Lengths differ\");\n\n    // safe as we've already bounds checked the array lengths\n    uint256 n = makers.length;\n\n    require(n > 0, \"TDR: Received empty arrays\");\n\n    for (uint256 i = 0; i < n; i++) {\n        // verify each order individually and together\n        if (\n            !isValidSignature(makers[i].order.maker, makers[i]) ||\n            !isValidSignature(takers[i].order.maker, takers[i]) ||\n            !isValidPair(takers[i], makers[i])\n        ) {\n            // skip if either order is invalid\n            continue;\n        }\n"
    },
    "Use of incorrect index leads to incorrect updation of funding rates": {
        "desc": "The `updateFundingRate()` function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of `[currentFundingIndex]` which has been updated since the previous call to this function while it should really be using `[currentFundingIndex-1]` to reference the previous funding rate.\nThe impact of this, is that the cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and the protocol takes a reputation hit.",
        "patch": "\nfunction updateFundingRate() internal {\n    // Get 8 hour time-weighted-average price (TWAP) and calculate the new funding rate and store it a new variable\n    ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);\n    Prices.TWAP memory twapPrices = getTWAPs(currentHour);\n    int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();\n    uint256 underlyingTWAP = twapPrices.underlying;\n    uint256 derivativeTWAP = twapPrices.derivative;\n\n    int256 newFundingRate = PRBMathSD59x18.mul(\n        derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,\n        _tracer.fundingRateSensitivity().toInt256()\n    );\n\n    // Create variable with value of new funding rate value\n    int256 currentFundingRateValue = 0;\n    if (currentFundingIndex > 0) {\n        currentFundingRateValue = fundingRates[currentFundingIndex - 1].cumulativeFundingRate;\n    }\n    int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;\n\n    // as above but with insurance funding rate value\n    int256 currentInsuranceFundingRateValue = 0;\n    if (currentFundingIndex > 0) {\n        currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex - 1].cumulativeFundingRate;\n    }\n    int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;\n\n    // Call setter functions on calculated variables\n    setFundingRate(newFundingRate, cumulativeFundingRate);\n    emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);\n    setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);\n    emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);\n    // increment funding index\n    currentFundingIndex = currentFundingIndex + 1;\n}\n"
    },
    "Logic error in fee subtraction": {
        "desc": "In `LibBalances.applyTrade()`, we need to collect a fee from the trade. However, the current code subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see `TracerPerpetualSwaps.sol` L272).\nThis issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.",
        "patch": "\nfunction applyTrade(\n        Balances.Position calldata position,\n        Balances.Trade calldata trade,\n        uint256 feeRate\n    ) external pure returns (Balances.Position memory) {\n        // Deduct fee from both short and long positions\n        int256 fee = getFee(trade.amount, trade.executionPrice, feeRate);\n        position.short = position.short - fee;\n        position.long = position.long - fee;\n        \n        return position;\n    }\n\nfunction getFee(\n        uint256 amount,\n        uint256 executionPrice,\n        uint256 feeRate\n    ) internal pure returns (int256) {\n        uint256 quoteChange = PRBMathUD60x18.mul(amount, executionPrice);\n\n        // Calculate fee\n        int256 fee = PRBMathUD60x18.mul(quoteChange, feeRate).toInt256();\n        return fee;\n    }\n\nfunction mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n"
    },
    "Insurance slippage reimbursement can be used to steal insurance fund": {
        "desc": "The `Liquidation` contract allows the liquidator to submit \"bad\" trade orders and the insurance reimburses them from the insurance fund, see `Liquidation.claimReceipt`.\nThe function can be called with an `orders` array, which does not check for duplicate orders.\nAn attacker can abuse this to make a profit by liquidating themselves, making a small bad trade and repeatedly submitting this bad trade for slippage reimbursement.\n**Example**:\n- Attacker uses two accounts, one as the liquidator and one as the liquidatee.\n- They run some high-leverage trades such that the liquidatee gets liquidated with the next price update. (If not cash out and make a profit this way through trading, and try again.)\n- Liquidator liquidates liquidatee\n- They now do two trades:\n  - One \"good\" trade at the market price that fills 99% of the liquidation amount. The slippage protection should not kick in for this trade\n  - One \"bad\" trade at a horrible market price that fills only 1% of the liquidation amount. This way the slippage protection kicks in for this trade\n- The liquidator now calls `claimReceipt(orders)` where `orders` is an array that contains many duplicates of the \"bad\" trade, for example 100 times. The `calcUnitsSold` function will return `unitsSold = receipt.amountLiquidated` and a bad `avgPrice`. They are now reimbursed the price difference on the full liquidation amount (instead of only on 1% of it) making an overall profit\nThis can be repeated until the insurance fund is drained.\nThe attacker has an incentive to do this attack as it's profitable and the insurance fund will be completely drained.",
        "patch": "\nfunction claimReceipt(\n        uint256 receiptId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) external override {\n        // Claim the receipts from the escrow system, get back amount to return\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(receipt.liquidator == msg.sender, \"LIQ: Liquidator mismatch\");\n        // Mark refund as claimed\n        require(!receipt.liquidatorRefundClaimed, \"LIQ: Already claimed\");\n        liquidationReceipts[receiptId].liquidatorRefundClaimed = true;\n        liquidationReceipts[receiptId].escrowClaimed = true;\n        require(block.timestamp < receipt.releaseTime, \"LIQ: claim time passed\");\n        require(tracer.tradingWhitelist(traderContract), \"LIQ: Trader is not whitelisted\");\n\n        // Check for duplicate orders in the 'orders' array\n        for (uint256 i = 1; i < orders.length; i++) {\n            require(orders[i].orderId > orders[i - 1].orderId, \"LIQ: Duplicate orders not allowed\");\n        }\n\n        uint256 amountToReturn = calcAmountToReturn(receiptId, orders, traderContract);\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            liquidationReceipts[receiptId].escrowedAmount = 0;\n        }\n"
    },
    "Wrong price scale for `GasOracle`": {
        "desc": "The `GasOracle` uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.\nHowever, the scaling depends on the underlying decimals of the two oracles and could be anything.\nBut the code assumes it's in 18 decimals.\n> \"Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\"\nThere is a `toWad` function that seems to involve scaling but it is never used.\nThe impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported.",
        "patch": "\nfunction latestAnswer() external view override returns (uint256) {\n    uint256 decimals = chainlink.decimals(); // Get decimals of the oracle answers\n    uint256 rawAnswer = oracle.latestAnswer(); // Get raw answer from the oracle\n    uint256 scaledAnswer = rawAnswer * (10**(18 - decimals)); // Scale the answer to 18 decimals\n    return scaledAnswer;\n}\n"
    },
    "treasury is vulnerable to sandwich attack": {
        "desc": "#### Impact\nThere's a permissionless function `veCRVlock` in `MochiTreasury`. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds.\n[MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)\nAttackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.\n#### Proof of Concept\n[MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)\nHere's an exploit pattern\n1.  Flashloan and buy CRV the uniswap pool\n2.  Trigger `veCRVlock()`\n3.  The treasury buys CRV at a very high price.\n4.  Sell CRV and pay back the loan.\n####",
        "patch": "\nfunction veCRVlock() external onlyOwner {\n    require(lockCrv, \"!lock\");\n    updateFee();\n    _buyCRV();\n    _lockCRV();\n    veCRVShare = 0;\n}\n"
    },
    "ERC-721 Enumerable Spec mismatch for index of `tokenByIndex()` function": {
        "desc": "Index starts at 0 for token array, but the implementation here requires index to be greater than 0. This will prevent querying of tokens at index 0.\nSee [reference implementation].\nThis will impact compatibility with NFT platforms that expect full conformity with ERC-721 specification.",
        "patch": "\n\n"
    },
    "Signature malleability of EVM's `ecrecover` in `verify()`": {
        "desc": "EVM's `ecrecover` is susceptible to signature malleability, which allows replay attacks, but that is mitigated here by tracking accepted offers and canceling them (on L645) specifically to prevent replays. However, if any application logic changes, it might make signature malleability a risk for replay attacks.\nSee [reference](https://swcregistry.io/docs/SWC-117).",
        "patch": "\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nfunction verify(address signer, bytes32 hash, bytes memory signature) internal pure returns (bool) {\n    require(signature.length == 65);\n\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    assembly {\n        r := mload(add(signature, 32))\n        s := mload(add(signature, 64))\n        v := byte(0, mload(add(signature, 96)))\n    }\n\n    return ECDSA.recover(hash, v, r, s) == signer;\n}\n"
    },
    "Arbitrary Transfer of Unowned NFTs": {
        "desc": "Due to how the market functions are structured, it is possible to arbitrarily transfer any NFT that is not owned by any address.\nThe function in question is the `tradeValid` function invoked by `acceptTrade` before the trade is performed. It, in turn, validates the signature of a trade via `verify`, which does not account for the behavior of `ecrecover`.\nWhen `ecrecover` is invoked with an invalid signature, the zero-address is returned by it, meaning that `verify` will yield `true` for the zero-address as long as the signature provided is invalid.\nThis can be exploited to transfer any NFT whose `idToOwner` is zero, including NFTs that have not been minted yet.",
        "patch": "\nfunction verify(address signer, bytes32 hash, bytes memory signature) internal pure returns (bool) {\n        require(signature.length == 65);\n        require(signer != address(0), \"Invalid signer address\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n            v := byte(0, mload(add(signature, 96)))\n        }\n"
    },
    "function `tokenByIndex` treats last index as invalid": {
        "desc": "NFT indexes start from 0:\n```solidity\n// Don't allow a zero index, start counting at 1\nreturn value.add(1);\n```\nSo if there are 30 tokens, indexes would be 1-30. However, function `tokenByIndex` sets such boundaries:\n```solidity\nrequire(index > 0 && index < TOKEN_LIMIT);\n```\nThis means that the last token (with index 30 in this case) will not be valid.",
        "patch": "\nfunction tokenByIndex(uint256 index) public pure returns (uint256) {\n        require(index > 0 && index <= TOKEN_LIMIT);\n        return index;\n    }\n"
    },
    "implicit underflows": {
        "desc": "There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert.\n* `int256(a-b)` where a and b are uint: For example, if `a=1` and `b=2`, then the intermediate result would be `uint(-1) == 2**256-1`\n* `int256(-x)` where x is a uint. For example, if `x=1`, then the intermediate result would be `uint(-1) == 2**256-1`\nIt's better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x.\nFrom `Exposure.sol` [L178](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178):\n```solidity\nfunction sortVaultsByDelta(..)\n..\n    for (uint256 i = 0; i < N_COINS; i++) {\n        // Get difference between vault current assets and vault target\n        int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result\n```\nFrom `PnL.sol` [L112](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pnl/PnL.sol#L112):\n```solidity\n function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)...\n..\n emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result\n```\nFrom `Buoy3Pool.sol` [L87](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L87):\n```solidity\nfunction safetyCheck() external view override returns (bool) {\n    ...\n        _ratio = abs(int256(_ratio - lastRatio[i])); // underflow in intermediate result\n```",
        "patch": "\n\n"
    },
    "Incorrect use of operator leads to arbitrary minting of GVT tokens": {
        "desc": "The `distributeStrategyGainLoss()` function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced on `msg.sender` by checking that `vaultIndexes[msg.sender]` is a valid index range 1-4. However, the operator used in the `require()` is `||` instead of `&&`, which allows an arbitrary `msg.sender`, i.e. attacker, to bypass the check.\n**Scenario**: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value in `vaultIndexes[msg.sender]`, which will fail the `> 0` check, but pass the `<= N_COINS + 1` check (`N_COINS = 3`) because `0 <= 4` which will allow control to go past this check.\nFurthermore, on L362, `index=0` will underflow the -1 decrement (due to lack of `SafeMath.sub` and use of < 0.8.0 solc) and the index will be set to `(uint256_MAX - 1)`. This will allow execution to proceed to the \"else\" part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.\nThe attack control flow:\n* -> `Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0)`\n* -> `index = 0` passes check for the `index <= N_COINS + 1` part of predicate on L357 in `Controller.sol`\n* -> `index = uint256_MAX` after L362\n* -> `gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN);` on L371 in `Controller.sol`\n* -> `ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);` on L376 in `Controller.sol`\n* -> `(gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);` on L254 in `PnL.sol`\n* -> `performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);` on L186 of `PnL.sol`\n* ->  `gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);` on L256 in `PnL.sol`",
        "patch": "\nfunction distributeStrategyGainLoss(\n        uint256 gain,\n        uint256 loss,\n        address reward\n    ) external override {\n        require(vaultIndexes[msg.sender] > 0 && vaultIndexes[msg.sender] <= N_COINS + 1, \"Unauthorized caller\");\n}\n"
    },
    "`sortVaultsByDelta` doesn't work as expected": {
        "desc": "The function `sortVaultsByDelta` doesn't always work as expected.\nSuppose all the delta's are positive, and delta1 >= delta2 >= delta3 > 0. Then `maxIndex = 0`. And `(delta < minDelta (==0) )` is never true, so `minIndex = 0`.\nThen (assuming `bigFirst==true`):\n```solidity\nvaultIndexes[0] = maxIndex = 0\nvaultIndexes[2] = minIndex = 0\nvaultIndexes[1] = N_COINS - maxIndex - minIndex = 3-0-0 = 3\n```\nThis is clearly not what is wanted, all `vaultIndexes` should be different and should be in the range [0..2]. This is due to the fact that `maxDelta` and `minDelta` are initialized with the value 0. This all could results in withdrawing from the wrong vaults and reverts (because `vaultIndexes`[1]  is out of range).\n`Exposure.sol` [L178](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178):\n```solidity\nfunction sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {\n        uint256 maxIndex;\n        uint256 minIndex;\n        int256 maxDelta;\n        int256 minDelta;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            // Get difference between vault current assets and vault target\n            int256 delta = int256(\n                unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)\n            );\n            // Establish order\n            if (delta > maxDelta) {\n                maxDelta = delta;\n                maxIndex = i;\n            } else if (delta < minDelta) {\n                minDelta = delta;\n                minIndex = i;\n            }\n        }\n        if (bigFirst) {\n            vaultIndexes[0] = maxIndex;\n            vaultIndexes[2] = minIndex;\n        } else {\n            vaultIndexes[0] = minIndex;\n            vaultIndexes[2] = maxIndex;\n        }\n        vaultIndexes[1] = N_COINS - maxIndex - minIndex;\n    }\n```",
        "patch": "\nfunction sortVaultsByDelta(bool bigFirst) external view override returns (uint256[3] memory) {\n    int256 maxDelta = -2**255; // Initialize with very negative value\n    int256 minDelta = 2**255; // Initialize with very positive value\n    uint256 maxIndex;\n    uint256 minIndex;\n    \n    for (uint256 i = 0; i < N_COINS; i++) {\n        // Get difference between vault current assets and vault target\n        int256 delta = int256(\n            unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)\n        );\n\n        // Establish order\n        if (delta > maxDelta) {\n            maxDelta = delta;\n            maxIndex = i;\n        } else if (delta < minDelta) {\n            minDelta = delta;\n            minIndex = i;\n        }\n    }\n\n    // Check that maxIndex and minIndex are not the same\n    require(maxIndex != minIndex, \"maxIndex and minIndex cannot be the same\");\n\n    // Determine vault indexes based on sorting order\n    uint256[3] memory vaultIndexes;\n    if (bigFirst) {\n        vaultIndexes[0] = maxIndex;\n        vaultIndexes[2] = minIndex;\n    } else {\n        vaultIndexes[0] = minIndex;\n        vaultIndexes[2] = maxIndex;\n    }\n    vaultIndexes[1] = N_COINS - maxIndex - minIndex;\n    \n    return vaultIndexes;\n}\n"
    },
    "A previously timelocked NFT token becomes permanently stuck in vault if it\u2019s ever moved back into the vault": {
        "desc": "Let\u2019s consider a scenario where a particular NFT token was timelocked for a certain duration by the owner using `timeLockERC721()` with a delegate as the recipient and then transferred out of the vault by the delegate via `transferERC721()` but without unlocking it explicitly using `timeUnlockERC721()`.\nThis is possible because `transferERC721()` does all the timelock checks on `expires/block.timestamp` and `recipient/msg.sender` as is done in `timeUnlockERC721()`. But it misses deleting `timelockERC721s[key]` for that NFT `tokenID` (as done in L572 of `timeUnlockERC721()`).\nBecause of this missing deletion, if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the `transferERC721()` call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock).\nThe impact is that, without access/control to the earlier timelock recipient, this NFT token is now locked in the vault forever.\n1. Alice time locks a particular NFT token with delegate Eve as recipient using `timeLockERC721()`\n2. Eve transfers NFT to Bob using `transferERC721()` but without calling `timeUnlockERC721()` first\n3. Alice buys the same NFT back from Bob (e.g. because it is now considered rare and more valuable) and again puts it back in her vault but this time without locking/delegating it to any recipient i.e. intending to control it herself.\n4. Because this NFT's timelock data and delegate approval for Eve is never removed after Step 2, the NFT is still treated as timelocked in the vault with previous delegate Eve as the recipient (because of stale data in `timelockERC721s` and `nftApprovals`)\n5. Alice now cannot withdraw her own NFT without Eve\u2019s help because the check on L510 will only allow Eve to transfer this NFT out of the vault.\n6. If Eve is no longer trusted/accessible then the NFT is locked in the vault forever.",
        "patch": "\nfunction transferERC721(\n        address to,\n        address nftContract,\n        uint256 tokenId\n    ) external {\n        if(msg.sender != _getOwner()) {\n            require(nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], \"NFT not approved for transfer\");\n        }\n\n        // Add this line to delete timelockERC721 data associated with the transferred NFT token\n        delete timelockERC721s[keccak256(abi.encodePacked(nftContract, tokenId))];\n    }\n"
    },
    "NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens": {
        "desc": "NFT transfer approvals that are set to true in `approveTransferERC721()` are never set to false and there is no way to remove such an nft approval.\n**Impact 1**: The approval is not removed (set to false) after a transfer in `transferERC721()`. So if the NFT is ever moved back into the owner's vault again, then the previous/compromised delegate can again transfer it to any address of choice without requiring a new approval.\n**Impact 2**: If a delegate becomes compromised/untrustworthy after granting approval but before transfer then the owner will lose its NFT because there is no mechanism to revoke the approval that was granted earlier.\n[PoC-1]:\n* Alice grants Eve approval to transfer a particular NFT out of its vault using `approveTransferERC721()`\n* Eve, who has transfer rights to that NFT from Alice\u2019s vault,  transfers that NFT to Bob using `transferERC721()`\n* Alice decides to buy back that NFT (e.g. because it is now considered rare and more valuable) from Bob and transfers it back to its vault\n* Eve, who continues to have transfer rights to that NFT from Alice\u2019s vault, can steal that NFT and transfer to anyone\n[PoC-2]:\n* Alice grants Eve approval to transfer a particular NFT out of its vault using `approveTransferERC721()`\n* Alice learns that Eve\u2019s keys are compromises or that Eve is malicious and wants to revoke the approval but there is no mechanism to do so\n* Eve (or whoever stole her credentials) has transfer rights to that NFT from Alice\u2019s vault and can steal that NFT and transfer to anyone",
        "patch": "\nfunction approveTransferERC721(\n      address delegate, \n      address nftContract, \n      uint256 tokenId,\n      bool approval\n    ) external onlyOwner {\n      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = approval;\n    }\n\nfunction transferERC721(\n        address to,\n        address nftContract,\n        uint256 tokenId\n    ) external {\n        if(msg.sender != _getOwner()) {\n          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], \"NFT not approved for transfer\"); \n          approveTransferERC721(msg.sender, nftContract, tokenId, false); // Remove approval after transfer\n        }\nfunction _getOwner() internal view virtual returns (address owner);\n\n    function isValidSignature(bytes32 permissionHash, bytes memory signature)\n        public\n        view\n        override\n        returns (bytes4)\n    {\n        return\n            SignatureChecker.isValidSignature(_getOwner(), permissionHash, signature)\n                ? VALID_SIG\n                : INVALID_SIG;\n    }\n\nfunction _removeNft(address nftContract, uint256 tokenId) internal {\n      uint256 len = nfts.length;\n      for (uint256 i = 0; i < len; i++) {\n        Nft memory nftInfo = nfts[i];\n        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {\n          if(i != len - 1) {\n            nfts[i] = nfts[len - 1];\n          }\nfunction safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n"
    },
    "Approval for NFT transfers is not removed after transfer": {
        "desc": "The `Visor.transferERC721` does not reset the approval for the NFT.\nAn approved delegatee can move the NFT out of the contract once.\nIt could be moved to a market and bought by someone else who then deposits it again to the same vault.\nThe first delegatee can steal the NFT and move it out of the contract a second time.",
        "patch": "\nfunction transferERC721(\n    address to,\n    address nftContract,\n    uint256 tokenId\n) external {\n    if(msg.sender != _getOwner()) {\n        require(nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], \"NFT not approved for transfer\"); \n        delete nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))];\n    }\n}\n"
    },
    "Unbounded loop in `_removeNft` could lead to a griefing/DOS attack": {
        "desc": "Griefing/DOS attack is possible when a malicious NFT contract sends many NFTs to the vault, which could cause excessive gas consumed and even transactions reverted when other users are trying to unlock or transfer NFTs.\nThe function `_removeNft` uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas.\nThe function `onERC721Received` is permission-less. The vault accepts any NFTs from any NFT contract and pushes the received NFT into the array nfts.\nA malicious user could write an NFT contract, which calls `onERC721Received` of the vault many times to make the array nfts grow to a large size. Besides, the malicious NFT contract reverts when anyone tries to transfer (e.g., `safeTransferFrom`) its NFT.\nThe vault then has no way to remove the transferred NFT from the malicious NFT contract. The two only functions to remove NFTs, `transferERC721` and `timeUnlockERC721`, fail since the malicious NFT contract reverts all `safeTransferFrom` calls.\nAs a result, benign users who unlock or transfer NFTs would suffer from large and unnecessary gas consumption. The consumed gas could even exceed the block gas limit and cause the transaction to fail every time.",
        "patch": "\nfunction _removeNft(address nftContract, uint256 tokenId) internal {\n    uint256 len = nfts.length;\n    for (uint256 i = 0; i < len; i++) {\n        Nft memory nftInfo = nfts[i];\n        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {\n            if (i != len - 1) {\n                nfts[i] = nfts[len - 1];\n            }\n            nfts.pop(); // Remove the last element after moving\n            break; // Exit loop once the NFT is found and removed\n        }\n    }\n}\n"
    },
    "Anyone can arbitrarily add router liquidity": {
        "desc": "The `addLiquidity()` function takes a router address parameter, whose liquidity is increased (instead of assuming that `router` == `msg.sender` like is done on `removeLiquidity()`) on this contract/chain, by transferring the fund amount from router address to this contract if `assetID` != 0 (i.e. ERC20 tokens). However, anyone can call this function on the router\u2019s behalf. For `assetID` == 0, the Ether transfer via `msg.value` comes from `msg.sender` and hence is assumed to be the router itself.\nThe impact is that this will allow anyone to call this function and arbitrarily move ERC20 tokens from router address to this contract, assuming router has given max approval to this contract and has `assetID` amount available for transfer. While the router can always remove the liquidity if it doesn\u2019t want to maintain that level of liquidity, this lack of access control or flexibility for a relayer to add liquidity on router\u2019s behalf, may unnecessarily (and without authorization) increase the router\u2019s exposure to protocol risk to more than it desires. See `TransactionManager.sol` [#L88-L98]. See also, use of `msg.sender` in `removeLiquidity` ([#L88-L98]).",
        "patch": "\nfunction addLiquidity(uint256 amount, address assetId, address router) external payable override nonReentrant {\n    // Sanity check: nonzero amounts\n    require(amount > 0, \"addLiquidity: AMOUNT_IS_ZERO\");\n\n    // Validate correct amounts are transferred\n    if (LibAsset.isEther(assetId)) {\n        require(msg.value == amount, \"addLiquidity: VALUE_MISMATCH\");\n    }\n\n    // Ensure only the router can call this function\n    require(msg.sender == router, \"addLiquidity: ONLY_ROUTER_ALLOWED\");\n\n    // Liquidity addition logic...\n}\n"
    },
    "Router liquidity on receiving chain can be double-dipped by the user": {
        "desc": "During `fulfill()` on the receiving chain, if the user has set up an external contract at `txData.callTo`, the catch blocks for both `IFulfillHelper.addFunds()` and `IFulfillHelper.excute()` perform `transferAsset` to the predetermined fallback address `txData.receivingAddress`.\nIf `addFunds()` has reverted earlier, `toSend` amount would already have been transferred to the `receivingAddress`. If `execute()` also fails, it is again transferred.\n**Scenario:** User sets up receiver chain `txData.callTo` contract such that both `addFunds()` and `execute()` calls revert. That will let him get twice the `toSend` amount credited to the `receivingAddress`. So effectively, Alice locks 100 `tokenAs` on chain A, and can get 200 `tokenAs` (or twice the amount of any token she is supposed to get on chain B from the router), minus relayer fee, on chain B. Router liquidity is double-dipped by Alice and router loses funds. See `TransactionManager.sol` [L395-L409] and [L413-L428].",
        "patch": "\nfunction execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public payable virtual onlyRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\nfunction fulfill(\n    TransactionData calldata txData,\n    uint256 relayerFee,\n    bytes calldata signature, // signature on fee + digest\n    bytes calldata callData\n  ) external override nonReentrant returns (TransactionData memory) {\n    // Get the hash of the invariant tx data. This hash is the same\n    // between sending and receiving chains. The variant data is stored\n    // in the contract when `prepare` is called within the mapping.\n    bytes32 digest = hashInvariantTransactionData(txData);\n\n    // Make sure that the variant data matches what was stored\n    require(variantTransactionData[digest] == hashVariantTransactionData(txData), \"fulfill: INVALID_VARIANT_DATA\");\n\n    // Make sure the expiry has not elapsed\n    require(txData.expiry > block.timestamp, \"fulfill: EXPIRED\");\n\n    // Make sure the transaction wasn't already completed\n    require(txData.preparedBlockNumber > 0, \"fulfill: ALREADY_COMPLETED\");\n\n    // Validate the user has signed\n    require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, \"fulfill: INVALID_SIGNATURE\");\n\n    // Sanity check: fee <= amount. Allow `=` in case of only wanting to execute\n    // 0-value crosschain tx, so only providing the fee amount\n    require(relayerFee <= txData.amount, \"fulfill: INVALID_RELAYER_FEE\");\n\n    // Check provided callData matches stored hash\n    require(keccak256(callData) == txData.callDataHash, \"fulfill: INVALID_CALL_DATA\");\n\n    // To prevent `fulfill` / `cancel` from being called multiple times, the\n    // preparedBlockNumber is set to 0 before being hashed. The value of the\n    // mapping is explicitly *not* zeroed out so users who come online without\n    // a store can tell the difference between a transaction that has not been\n    // prepared, and a transaction that was already completed on the receiver\n    // chain.\n    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({\n      amount: txData.amount,\n      expiry: txData.expiry,\n      preparedBlockNumber: 0\n    }\n\nfunction transferAsset(\n        address assetId,\n        address payable recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        return\n            isEther(assetId)\n                ? transferEther(recipient, amount)\n                : transferERC20(assetId, recipient, amount);\n    }\nfunction hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {\n    return keccak256(abi.encode(VariantTransactionData({\n      amount: txData.amount,\n      expiry: txData.expiry,\n      preparedBlockNumber: txData.preparedBlockNumber\n    }\nfunction isEther(address assetId) internal pure returns (bool) {\n        return assetId == ETHER_ASSETID;\n    }\n\nfunction removeUserActiveBlocks(address user, uint256 preparedBlock) internal {\n    // Remove active blocks\n    uint256 newLength = activeTransactionBlocks[user].length - 1;\n    uint256[] memory updated = new uint256[](newLength);\n    bool removed = false;\n    uint256 updatedIdx = 0;\n    for (uint256 i; i < newLength + 1; i++) {\n      // Handle case where there could be more than one tx added in a block\n      // And only one should be removed\n      if (!removed && activeTransactionBlocks[user][i] == preparedBlock) {\n        removed = true;\n        continue;\n      }\nfunction hashInvariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {\n    InvariantTransactionData memory invariant = InvariantTransactionData({\n      user: txData.user,\n      router: txData.router,\n      sendingAssetId: txData.sendingAssetId,\n      receivingAssetId: txData.receivingAssetId,\n      sendingChainFallback: txData.sendingChainFallback,\n      callTo: txData.callTo,\n      receivingAddress: txData.receivingAddress,\n      sendingChainId: txData.sendingChainId,\n      receivingChainId: txData.receivingChainId,\n      callDataHash: txData.callDataHash,\n      transactionId: txData.transactionId\n    }\n\n\nfunction approve(\n        address assetId,\n        address spender,\n        uint256 amount\n    ) internal returns (bool) {\n        return\n            wrapCall(\n                assetId,\n                abi.encodeWithSignature(\n                    \"approve(address,uint256)\",\n                    spender,\n                    amount\n                )\n            );\n    }\n\nfunction recoverFulfillSignature(\n    TransactionData calldata txData,\n    uint256 relayerFee,\n    bytes calldata signature\n  ) internal pure returns (address) {\n    // Create the signed payload\n    SignedFulfillData memory payload = SignedFulfillData({transactionId: txData.transactionId, relayerFee: relayerFee}\n"
    },
    "Expired transfers will lock user funds on the sending chain": {
        "desc": "The cancelling relayer is being paid in `receivingAssetId` on the `sendingChain` instead of in `sendingAssetID`. If the user relies on a relayer to cancel transactions, and that `receivingAssetId` asset does not exist on the sending chain (assuming only `sendingAssetID` on the sending chain and `receivingAssetId` on the receiving chain are assured to be valid and present), then the cancel transaction from the relayer will always revert and user\u2019s funds will remain locked on the sending chain.\nThe impact is that expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.",
        "patch": "\nfunction transferAsset(\n    address assetId,\n    address payable recipient,\n    uint256 amount\n) internal returns (bool) {\n    return\n        isEther(assetId)\n            ? transferEther(recipient, amount)\n            : transferERC20(sendingAssetId, recipient, amount);\n}\n"
    },
    "`Approval` is not reset if the call to `IFulfillHelper` fails": {
        "desc": "The function `fulfill` first approves the `callTo` to transfer an amount of `toSend` tokens and tries to call `IFulfillHelper`, but if the call fails, it transfers these assets directly. However, in such case the approval is not reset, so a malicous `callTo` can pull these tokens later:\n```solidity\n// First, approve the funds to the helper if needed\n    if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {\n      require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\");\n    }\n    // Next, call `addFunds` on the helper. Helpers should internally\n    // track funds to make sure no one user is able to take all funds\n    // for tx\n    if (toSend > 0) {\n      try\n        IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(\n          txData.user,\n          txData.transactionId,\n          txData.receivingAssetId,\n          toSend\n        )\n      {} catch {\n        // Regardless of error within the callData execution, send funds\n        // to the predetermined fallback address\n        require(\n          LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),\n          \"fulfill: TRANSFER_FAILED\"\n        );\n      }\n    }\n```\n[Tuesday, August 10, 2021](x-fantastical3://show/calendar/2021-08-18)",
        "patch": "\nfunction fulfill(\n    TransactionData calldata txData,\n    uint256 relayerFee,\n    bytes calldata signature, // signature on fee + digest\n    bytes calldata callData\n  ) external override nonReentrant returns (TransactionData memory) {\n    // Get the hash of the invariant tx data. This hash is the same\n    // between sending and receiving chains. The variant data is stored\n    // in the contract when `prepare` is called within the mapping.\n    bytes32 digest = hashInvariantTransactionData(txData);\n\n    // Make sure that the variant data matches what was stored\n    require(variantTransactionData[digest] == hashVariantTransactionData(txData), \"fulfill: INVALID_VARIANT_DATA\");\n\n    // Make sure the expiry has not elapsed\n    require(txData.expiry > block.timestamp, \"fulfill: EXPIRED\");\n\n    // Make sure the transaction wasn't already completed\n    require(txData.preparedBlockNumber > 0, \"fulfill: ALREADY_COMPLETED\");\n\n    // Validate the user has signed\n    require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, \"fulfill: INVALID_SIGNATURE\");\n\n    // Sanity check: fee <= amount. Allow `=` in case of only wanting to execute\n    // 0-value crosschain tx, so only providing the fee amount\n    require(relayerFee <= txData.amount, \"fulfill: INVALID_RELAYER_FEE\");\n\n    // Check provided callData matches stored hash\n    require(keccak256(callData) == txData.callDataHash, \"fulfill: INVALID_CALL_DATA\");\n\n    // To prevent `fulfill` / `cancel` from being called multiple times, the\n    // preparedBlockNumber is set to 0 before being hashed. The value of the\n    // mapping is explicitly *not* zeroed out so users who come online without\n    // a store can tell the difference between a transaction that has not been\n    // prepared, and a transaction that was already completed on the receiver\n    // chain.\n    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({\n      amount: txData.amount,\n      expiry: txData.expiry,\n      preparedBlockNumber: 0\n    }));\n\n    // First, approve the funds to the helper if needed\n    if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {\n      try\n        IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(\n          txData.user,\n          txData.transactionId,\n          txData.receivingAssetId,\n          toSend\n        )\n      {\n        // Approval successful, no further action needed\n      } catch {\n        // Reset approval if the call fails\n        if (toSend > 0) {\n          require(\n            LibERC20.approve(txData.receivingAssetId, txData.callTo, 0),\n            \"fulfill: RESET_APPROVAL_FAILED\"\n          );\n        }\n\n        // Regardless of error within the callData execution, send funds\n        // to the predetermined fallback address\n        require(\n          LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),\n          \"fulfill: TRANSFER_FAILED\"\n        );\n      }\n    }\n  }\n"
    },
    "`findNewOwner` edgecase": {
        "desc": "In the function `findNewOwner` of `RCOrderbook`, as loop is done which included the check  `_loopCounter < maxDeletions`\nAfterwards, a check is done for  \"(_loopCounter != maxDeletions)\" to determine if the processing is finished.\nIf `_loopCounter == maxDeletions` then the conclusion is that it isn't finished yet.\nHowever, there is the edgecase that the processing might just be finished at the same time as `_loopCounter == maxDeletions`.\nYou can see this the best if you assume `maxDeletions==1`, in that case it will never draw the conclusion it is finished.\nOf course having `maxDeletions==1` is very unlikely in practice.\n```solidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549\n function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  {\n...\n    // delete current owner\n    do {\n        _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );\n        _loopCounter++;             // delete next bid if foreclosed\n    } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&\n            _loopCounter < maxDeletions );\n    if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner\n        _newOwner = ....\n        ...\n    } else {\n        // we hit the limit, save the old owner, we'll try again next time\n        ...\n    }\n}\n```",
        "patch": "\nfunction findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)\n    external\n    override\n    onlyMarkets\n{\n    address _newOwner = address(0);\n    address _market = msgSender();\n    // the market is the head of the list, the next bid is therefore the owner\n    Bid storage _head = user[_market][index[_market][_market][_card]];\n    address _oldOwner = address(0);\n    uint256 _oldPrice = 0;\n    if (oldOwner[_market][_card] != address(0)) {\n        _oldOwner = oldOwner[_market][_card];\n        _oldPrice = oldPrice[_market][_card];\n        oldOwner[_market][_card] = address(0);\n        oldPrice[_market][_card] = 0;\n    }\n    // Mitigation: Double-check that _deletionLimit is greater than 1\n    require(maxDeletions > 1, \"findNewOwner: Deletion limit must be greater than 1\");\n}\n"
    },
    "`distribute` DoS on missing `receiveRewards` implementation": {
        "desc": "`NFTXEligiblityManager._sendForReceiver` should check `returnData.length == 1` before decoding. Otherwise, if it returns no return data, the `abi.decode` call will revert and with it the whole `distribute` function .\nA single poorly implemented `feeReceiver` can break the whole `distribute` function and allow a denial of service by reverting the transaction.",
        "patch": "\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 _tokenBalance, uint256 _allocTotal) internal {\n    uint256 amountToSend = _tokenBalance * _receiver.allocPoint / _allocTotal;\n    // If we're at this point we know we have more than enough to perform this safely.\n    uint256 balance = IERC20Upgradeable(_vault).balanceOf(address(this)) - 1000;\n    amountToSend = amountToSend > balance ? balance : amountToSend;\n    if (_receiver.isContract) {\n      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n      // If the receive is not properly processed, send it to the treasury instead.\n       \n      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n      (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);\n      bool tokensReceived = returnData.length == 1 && abi.decode(returnData, (bool));\n      if (!success || !tokensReceived) {\n        console.log(\"treasury fallback\");\n        IERC20Upgradeable(_vault).safeTransfer(treasury, amountToSend);\n      }\n}\n"
    },
    "`getRandomTokenIdFromFund` yields wrong probabilities for ERC1155": {
        "desc": "`NFTXVaultUpgradeable.getRandomTokenIdFromFund` does not work with ERC1155 as it does not take the deposited `quantity1155` into account.\nAssume `tokenId0` has a count of 100, and `tokenId1` has a count of 1.\nThen `getRandomId` would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.\nThis might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.",
        "patch": "\nfunction getRandomTokenIdFromFund() internal virtual returns (uint256) {\n    uint256 totalQuantity = getTotalQuantityOfTokens(); // Function to calculate total quantity of tokens in the vault\n    uint256 randomIndex = getPseudoRand(totalQuantity); // Use total quantity for random selection\n    return holdings.at(randomIndex);\n}\n\nfunction getTotalQuantityOfTokens() internal view returns (uint256) {\n    uint256 totalQuantity = 0;\n    for (uint256 i = 0; i < holdings.length(); i++) {\n        uint256 tokenId = holdings.at(i);\n        totalQuantity += quantity1155[tokenId]; // Add quantity of each token\n    }\n    return totalQuantity;\n}\n"
    },
    "`NFTXLPStaking` Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault": {
        "desc": "The LPStaking contract does not require that a stake be locked for any period of time. The LPStaking contract also does not track how long your stake has been locked. So an attacker Alice can stake, claim rewards, and unstake, all in one transaction. If Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.\nThe fact that the `NFTXVaultUpgradeable` contract contains a native `flashLoan` function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.\nSince a flash loan will easily dwarf all of the legitimate stakers' size of stake, the contract will erroneously award nearly all of the rewards to Alice.\n1.  Wait until an NFTX vault has accrued any significant amount of fees/rewards\n2.  `FlashLoanBorrow` a lot of ETH using any generic flash loan provider\n3.  `FlashLoanBorrow` a lot of nftx-vault-token using `NFTXVaultUpgradeable.flashLoan()`\n4.  Deposit the ETH and nftx-vault-token's into Uniswap for Uniswap LP tokens by calling `Uniswap.addLiquidity()`\n5.  Stake the Uniswap LP tokens in `NFTXLPStaking` by calling `NFTXLPStaking.deposit()`\n6.  Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling `NFTXLPStaking.claimRewards()`\n7.  Remove LP tokens from `NFTXLPStaking` by calling `NFTXLPStaking.exit()`;\n8.  Withdraw ETH and nftx-vault-token's by calling `Uniswap.removeLiquidity()`;\n9.  Pay back nftx-vault-token flash loan\n10. Pay back ETH flash loan\nSee [GitHub issue page](https://github.com/code-423n4/2021-05-nftx-findings/issues/88) for an in-depth  example.",
        "patch": "\nfunction deposit(uint256 vaultId, uint256 amount) external {\n    // Check the pool in case it's been updated.\n    updatePoolForVault(vaultId);\n    StakingPool memory pool = vaultStakingInfo[vaultId];\n    require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n    require(IERC20Upgradeable(pool.stakingToken).transferFrom(msg.sender, address(this), amount));\n    // Implementing locking periods or requiring rewards to be claimed after a certain period can mitigate flash loan attacks.\n    // Alternatively, if immediate unstaking is allowed, rewards can be claimed only for stakes that have been staked for a certain period.\n    // These changes would involve design changes and possibly new variables to track staking duration.\n    _rewardDistributionTokenAddr(pool).mint(msg.sender, amount);\n}\n"
    },
    "Controller does not raise an error when there's insufficient liquidity": {
        "desc": "#### Impact\nWhen a user tries to withdraw the token from the vault, the vault would withdraw the token from the controller if there's insufficient liquidity in the vault. However, the controller does not raise an error when there's insufficient liquidity in the controller/ strategies. The user would lose his shares while getting nothing.\nAn MEV searcher could apply this attack on any withdrawal. When an attacker found an unconfirmed tx that tries to withdraw 1M dai, he can do such sandwich attack.\n1.  Deposits USDC into the vault.\n2.  Withdraw all dai left in the vault/controller/strategy.\n3.  Place the vitims tx here. The victim would get zero dai while burning 1 M share. **This would pump the share price.**\n4.  Withdraw all liquidity.\nAll users would be vulnerable to MEV attackers. I consider this is a high-risk issue.\n#### Proof of Concept\nHere's web3.py script to reproduce the issue.\n```python\ndeposit_amount = 100000 * 10**18\nuser = w3.eth.accounts[0]\nget_token(dai, user, deposit_amount)\ndai.functions.approve(vault.address, deposit_amount + margin_deposit).transact()\nvault.functions.deposit(dai.address, deposit_amount).transact()\nvault.functions.withdrawAll(usdt.address).transact()\n#\nprint(\"usdt amount: \", usdt.functions.balanceOf(user).call())\n```\n####",
        "patch": "\nfunction withdrawAll(address _output) external {\n    unstake(userInfo[msg.sender].amount);\n    if (balanceOf(msg.sender) > 0) {\n        withdraw(balanceOf(msg.sender), _output);\n    }\n}\n"
    },
    "Self transfer can lead to unlimited mint": {
        "desc": "The implementation of the transfer function in [`nTokenAction.sol`]( https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol) is different from the usual erc20 token transfer function.\n This happens because it counts the incentive that the user gets, but with a self-transfer,  it can lead to unlimited mint. In [L278](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#_L278), it makes the amount negative, but in [L279](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279), it returns the value to an amount that is not negative. So, in the [L281-282](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282), it finalizes a positive value, only because the negative value is changed to the positive value.\n You can interact with this transfer function through [nTokenERC20Proxy.sol](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol).",
        "patch": "\nfunction transfer(address dst, uint256 wad) public returns (bool) {\n    require(msg.sender != dst, \"ERC20: cannot transfer to self\");\n    return transferFrom(msg.sender, dst, wad);\n}\n\nfunction _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n    _balances[sender] -= amount;\n    if (transferFee != 0) {\n        uint fee = amount * transferFee / 1e18;\n        amount = amount - fee;\n    }\n}\n"
    },
    "Access restrictions on `CompoundToNotionalV2.notionalCallback` can be bypassed": {
        "desc": "The `CompoundToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback. But, the access restrictions can be circumvented by simply providing `sender = this`, as `sender` is a parameter of the function that can be chosen by the attacker.\n```solidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n// @audit sender can be passed in by the attacker\nrequire(sender == address(this), \"Unauthorized callback\");\n```\nAn attacker can call the function passing in an arbitrary `account` whose tokens are then transferred to the contract.\nThe `account` first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker front-runs the actual transaction.\nIt's at least a griefing attack:\nI can pass in a malicious `cTokenBorrow` that returns any token of my choice (through the `.underlying()` call) but whose `repayBorrowBehalf` is a no-op.\nThis will lead to any of the victim's approved tokens becoming stuck in the contract, essentially burning them:\n```solidity\n// @audit using a malicious contract, this can be any token\naddress underlyingToken = CTokenInterface(cTokenBorrow).underlying();\nbool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\nrequire(success, \"Transfer of repayment failed\");\n// Use the amount transferred to repay the borrow\n// @audit using a malicious contract, this can be a no-op\nuint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n```\nNote that the assumption at the end of the function \"// When this exits a free collateral check will be triggered\" is not correct anymore but I couldn't find a way to make use of it to lead to an invalid account state.",
        "patch": "\nfunction notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(msg.sender == authorizedCaller, \"Unauthorized callback\"); // Fix authorization check\n        (\n            uint16 v1DebtCurrencyId,\n            uint128 v1RepayAmount,\n            uint16 v1CollateralId,\n            uint16 v2CollateralId\n        ) = abi.decode(callbackData, (uint16, uint128, uint16, uint16));\n\n        int256[] memory balances = Escrow.getBalances(account);\n        int256 collateralBalance =\n            (v1CollateralId == V1_ETH ? balances[V1_ETH] : balances[V1_WBTC]);\n        require(collateralBalance > 0);\n\n        {\n            INotionalV1Erc1155.Deposit[] memory deposits = new INotionalV1Erc1155.Deposit[](1);\n            INotionalV1Erc1155.Trade[] memory trades = new INotionalV1Erc1155.Trade[](0);\n            INotionalV1Erc1155.Withdraw[] memory withdraws = new INotionalV1Erc1155.Withdraw[](1);\n\n            // This will deposit what was borrowed from the account's wallet\n            deposits[0].currencyId = v1DebtCurrencyId;\n            deposits[0].amount = v1RepayAmount;\n\n            // This will withdraw to the current contract the collateral to repay the flash loan\n            withdraws[0].currencyId = v1CollateralId;\n            withdraws[0].to = address(this);\n            withdraws[0].amount = uint128(collateralBalance);\n\n            NotionalV1Erc1155.batchOperationWithdraw(\n                account,\n                uint32(block.timestamp),\n                deposits,\n                trades,\n                withdraws\n            );\n        }\n}\nfunction transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad, \"\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"\");\n            allowance[src][msg.sender] -= wad;\n        }\n}\n"
    },
    "Access restrictions on `NotionalV1ToNotionalV2.notionalCallback` can be bypassed": {
        "desc": "The `NotionalV1ToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing `sender = this` as `sender` is a parameter of the function that can be chosen by the attacker.\n```solidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n    require(sender == address(this), \"Unauthorized callback\");\n```\nAn attacker can call the function passing in an arbitrary `account` whose tokens can then be stolen.\nThe `account` first has to approve this contract but this can happen with accounts that legitimately want to migrate their tokens and therefore have to send a first transaction to approve the contract, but then an attacker frontruns the actual migration transaction.\nThe attacker can steal the tokens by performing an attack similar to the following:\n- first transaction is used to withdraw the victim's funds to the contract. This can be done by choosing `account=victim`, `v1RepayAmount=0`, `v1CollateralId=WBTC`, `v2CollateralId=DAI`. The [`NotionalV1Erc1155.batchOperationWithdraw`] (not part of this contest) will withdraw the victim's funds to this contract. Note that the attacker has to deposit the same `v2CollateralBalance = uint256(collateralBalance)` for the victim into the V2 version, but they can choose different cheaper collateral (for example, withdraw WBTC, deposit same amount of DAI).\n- second transaction is now used to deposit the victim funds in the contract into the user's account. They use `account=attacker`, `v1DebtCurrencyId=WBTC`, `v1RepayAmount=amount` to deposit it into Notional V1. (They need to have a small `collateralBalance`, etc. to pass all checks).",
        "patch": "\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n    require(msg.sender == address(this), \"Unauthorized callback\");\n\n    (\n        uint16 v1DebtCurrencyId,\n        uint128 v1RepayAmount,\n        uint16 v1CollateralId,\n        uint16 v2CollateralId\n    ) = abi.decode(callbackData, (uint16, uint128, uint16, uint16));\n\n    int256[] memory balances = Escrow.getBalances(account);\n    int256 collateralBalance =\n        (v1CollateralId == V1_ETH ? balances[V1_ETH] : balances[V1_WBTC]);\n    require(collateralBalance > 0);\n\n    {\n        INotionalV1Erc1155.Deposit[] memory deposits = new INotionalV1Erc1155.Deposit[](1);\n        INotionalV1Erc1155.Trade[] memory trades = new INotionalV1Erc1155.Trade[](0);\n        INotionalV1Erc1155.Withdraw[] memory withdraws = new INotionalV1Erc1155.Withdraw[](1);\n\n        // This will deposit what was borrowed from the account's wallet\n        deposits[0].currencyId = v1DebtCurrencyId;\n        deposits[0].amount = v1RepayAmount;\n\n        // This will withdraw to the current contract the collateral to repay the flash loan\n        withdraws[0].currencyId = v1CollateralId;\n        withdraws[0].to = address(this);\n        withdraws[0].amount = uint128(collateralBalance);\n\n        NotionalV1Erc1155.batchOperationWithdraw(\n            account,\n            uint32(block.timestamp),\n            deposits,\n            trades,\n            withdraws\n        );\n    }\n}\n"
    },
    "Potential DOS in Contracts Inheriting `UUPSUpgradeable.sol`": {
        "desc": "There are a number of contracts which inherit `UUPSUpgradeable.sol`, namely; `GovernanceAction.sol`, `PauseRouter.sol` and `NoteERC20.sol`.\nAll these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract.\nHowever, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the `onlyOwner` role in the implementation contract for `NoteERC20.sol`. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all `NoteERC20.sol` interactions until a new implementation contract is deployed.\nInitial information about this issue was found [here](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301).\nConsider the following scenario:\n- Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is `NoteERC20.sol`.\n- This allows any arbitrary user to call `initialize()` on the `NoteERC20.sol` implementation contract.\n- Once a user has gained control over `NoteERC20.sol`'s implementation contract, they can bypass the `_authorizeUpgrade` check used to restrict upgrades to the `onlyOwner` role.\n- The malicious user then calls `UUPSUpgradeable.upgradeToAndCall()` shown [here](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43) which in turn calls [this](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107) function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function.\n- As a result, the implementation contract will be self-destructed due to the user-controlled delegate call shown [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169), preventing all future calls to the `NoteERC20.sol` proxy contract until a new implementation contract has been deployed.",
        "patch": "\nfunction initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {\n    // Ensure initialization can only happen once\n    require(owner == address(0), \"R: already initialized\");\n\n    // Validate permissions before initializing\n    require(msg.sender == initialDeployer, \"Unauthorized\");\n\n    // List ETH as currency id == 1, NOTE: return value is ignored here\n    (bool status, ) =\n        address(GOVERNANCE).delegatecall(\n            abi.encodeWithSelector(\n                NotionalGovernance.listCurrency.selector,\n                TokenStorage(cETH, false, TokenType.cETH),\n                // No underlying set for cETH\n                TokenStorage(address(0), false, TokenType.Ether),\n                address(0),\n                false,\n                130, // Initial settings of 130 buffer\n                70,  // 70% haircut\n                105  // 105 liquidation discount\n            )\n        );\n    require(status);\n\n    // Set owner and other initial settings\n    owner = owner_;\n    pauseRouter = pauseRouter_;\n    pauseGuardian = pauseGuardian_;\n}\n"
    },
    "Liquidity token value can be manipulated": {
        "desc": "The liquidity token value (`AssetHandler.getLiquidityTokenValue`) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash.\nThe amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see `AssetHandler.getCashClaims` / `AssetHandler.getHaircutCashClaims`:\n```solidity\n// @audit token.notional are the LP tokens to redeem\nassetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\nfCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\n```\nThis means the value depends on the **current market reserves** which can be manipulated.\nYou're essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.\nSee the \"How do I tell if I\u2019m using spot price?\" section [here](https://shouldiusespotpriceasmyoracle.com/).\n> However, by doing this you\u2019re actually incorporating the spot price because you\u2019re still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about this [footgun](https://cmichel.io/pricing-lp-tokens/) in this writeup by @cmichelio.\nThe value of an LP token is computed as `assetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) )`, where `(assetCashClaim, fCashClaim)` depends on the current market reserves which can be manipulated by an attacker via flashloans.\nTherefore, an attacker trading large amounts in the market can either increase or decrease the value of an LP token.\nIf the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens.\nIf the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.\nThe exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage.\nIn constant-product AMMs like Uniswap it's profitable and several projects have already been exploited by this, like [warp.finance](https://cmichel.io/pricing-lp-tokens/).\nHowever, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles:\n> \"Oracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated.\" - Market.sol L424",
        "patch": "\nfunction getLiquidityTokenValue(\n    uint256 index,\n    CashGroupParameters memory cashGroup,\n    PortfolioAsset[] memory assets,\n    uint256 blockTime\n)\n    public\n    view\n    returns (\n        int256,\n        int256,\n        PortfolioAsset[] memory\n    )\n{\n    MarketParameters memory market;\n    int256 totalAssetCash = 0;\n    int256 totalfCash = 0;\n    \n    for (uint256 i = 0; i < assets.length; i++) {\n        int256 assetCashClaim;\n        int256 fCashClaim;\n        \n        // Calculate TWAP values for assetCashClaim and fCashClaim\n        (assetCashClaim, fCashClaim) = calculateTWAPValues(assets[i], blockTime);\n        \n        totalAssetCash += assetCashClaim;\n        totalfCash += fCashClaim;\n    }\n    \n    // Calculate liquidity token value based on TWAP values\n    int256 assetValue = calculateLiquidityTokenValue(totalAssetCash, totalfCash);\n\n    return (assetValue, 0, assets); // Assuming `pv` is not directly needed or calculated here\n}\n\n// Helper function to calculate TWAP values for assetCashClaim and fCashClaim\nfunction calculateTWAPValues(PortfolioAsset memory asset, uint256 blockTime) internal view returns (int256, int256) {\n    // Implement TWAP calculation logic here based on asset and blockTime\n    // Example logic:\n    int256 assetCashClaim = asset.totalAssetCash.mul(asset.notional).div(asset.totalLiquidity);\n    int256 fCashClaim = asset.totalfCash.mul(asset.notional).div(asset.totalLiquidity);\n\n    return (assetCashClaim, fCashClaim);\n}\n\n// Helper function to calculate liquidity token value based on TWAP values\nfunction calculateLiquidityTokenValue(int256 totalAssetCash, int256 totalfCash) internal view returns (int256) {\n    // Implement calculation of liquidity token value based on TWAP values\n    int256 liquidityTokenValue = totalAssetCash + totalfCash; // Example calculation\n\n    return liquidityTokenValue;\n}\n"
    },
    "Re-entrancy bug allows inflating balance": {
        "desc": "One can call the `MarginRouter.crossSwapExactTokensForTokens` function first with a fake contract disguised as a token pair:\n`crossSwapExactTokensForTokens(0.0001 WETH, 0, [ATTACKER_CONTRACT], [WETH, WBTC])`. When the amounts are computed by the `amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);` call, the attacker contract returns fake reserves that yield 1 WBTC for the tiny input. The resulting amount is credited through `registerTrade`. Afterwards, `_swapExactT4T([0.0001 WETH, 1 WBTC], 0, [ATTACKER_CONTRACT], [WETH, WBTC])` is called with the fake pair and token amounts. At some point `_swap` is called, the starting balance is stored in `startingBalance`, and the attacker contract call allows a re-entrancy:\n```solidity\npair.swap(0.0001 WETH, 1 WBTC, FUND, new bytes(0)); // can re-enter here\n```\nFrom the ATTACKER_CONTRACT we re-enter the `MarginRouter.crossSwapExactTokensForTokens(30 WETH, 0, WETH_WBTC_PAIR, [WETH, WBTC])` function with the actual WETH <> WBTC pair contract. All checks pass, the FUND receives the actual amount, the outer `_swap` continues execution after the re-entrancy and the `endingBalance >= startingBalance + amounts[amounts.length - 1]` check passes as well because the inner swap successfully deposited these funds. We end up doing 1 real trade but being credited twice the output amount.\nThis allows someone to be credited multiples of the actual swap result. This can be repeated many times and finally, all tokens can be stolen.",
        "patch": "\nfunction crossSwapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata pairs,\n    address[] calldata tokens,\n    uint256 deadline\n) external ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\n    // calc fees\n    uint256 fees = takeFeesFromInput(amountIn);\n\n    // checks that trader is within allowed lending bounds\n    uint256[] memory estimatedAmounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);\n\n    _swapExactT4T(estimatedAmounts, amountOutMin, pairs, tokens);\n\n    // swap\n    amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);\n\n    registerTrade(\n        msg.sender,\n        tokens[0],\n        tokens[tokens.length - 1],\n        amountIn,\n        amounts[amounts.length - 1]\n    );\n}\n\nfunction registerTrade(\n    address trader,\n    address inToken,\n    address outToken,\n    uint256 inAmount,\n    uint256 outAmount\n) internal nonReentrant {\n    (uint256 extinguishAmount, uint256 borrowAmount) =\n        IMarginTrading(marginTrading()).registerTradeAndBorrow(\n            trader,\n            inToken,\n            outToken,\n            inAmount,\n            outAmount\n        );\n    if (extinguishAmount > 0) {\n        Lending(lending()).payOff(outToken, extinguishAmount);\n        withdrawClaim(trader, outToken, extinguishAmount);\n    }\n}\n\nfunction _swapExactT4T(\n    uint256[] memory amounts,\n    uint256 amountOutMin,\n    address[] calldata pairs,\n    address[] calldata tokens\n) internal nonReentrant {\n    require(\n        amounts[amounts.length - 1] >= amountOutMin,\n        \"MarginRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\n    _swap(amounts, pairs, tokens, fund());\n}\n\nfunction _swap(\n    uint256[] memory amounts,\n    address[] memory pairs,\n    address[] memory tokens,\n    address _to\n) internal virtual {\n    address outToken = tokens[tokens.length - 1];\n    uint256 startingBalance = IERC20(outToken).balanceOf(_to);\n    for (uint256 i; i < pairs.length; i++) {\n        (address input, address output) = (tokens[i], tokens[i + 1]);\n        (address token0, ) = UniswapStyleLib.sortTokens(input, output);\n\n        uint256 amountOut = amounts[i + 1];\n\n        (uint256 amount0Out, uint256 amount1Out) =\n            input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n\n        address to = i < pairs.length - 1 ? pairs[i + 1] : _to;\n        IUniswapV2Pair pair = IUniswapV2Pair(pairs[i]);\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n}\n"
    },
    "Missing `fromToken != toToken` check": {
        "desc": "Attacker calls `MarginRouter.crossSwapExactTokensForTokens` with a fake pair and the same token[0] == token[1].\n`crossSwapExactTokensForTokens(1000 WETH, 0, [ATTACKER_CONTRACT], [WETH, WETH])`. When the amounts are computed by the `amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);` call, the attacker contract returns fake reserves that yield 0 output. When `_swapExactT4T` is called, the funds are sent to the fake contract and doing nothing passes all checks in `_swap` call that follows because the `startingBalance` is stored _after_ the initial Fund withdraw to the pair.\n```solidity\nfunction _swapExactT4T() {\n  // withdraw happens here\n    Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\n    _swap(amounts, pairs, tokens, fund());\n}\nfunction _swap() {\n  uint256 startingBalance = IERC20(outToken).balanceOf(_to);\n  uint256 endingBalance = IERC20(outToken).balanceOf(_to);\n  // passes as startingBalance == endingBalance + 0\n  require(\n      endingBalance >= startingBalance + amounts[amounts.length - 1],\n      \"Defective AMM route; balances don't match\"\n  );\n}\n```\nThe full impact is not yet known as `registerTrade` could still fail when subtracting the `inAmount` and adding 0 `outAmount`.\nAt least, this attack is similar to a withdrawal which is supposed to only occur after a certain `coolingOffPeriod` has passed, but this time-lock is circumvented with this attack.",
        "patch": "\nfunction _swapExactT4T(\n    uint256[] memory amounts,\n    uint256 amountOutMin,\n    address[] calldata pairs,\n    address[] calldata tokens\n) internal {\n    require(\n        amounts[amounts.length - 1] >= amountOutMin,\n        \"MarginRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    address outToken = tokens[tokens.length - 1];\n    uint256 startingBalance = IERC20(outToken).balanceOf(address(this)); // Ensure balance is checked before any external call\n    Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]); // Move fund withdrawal after balance check\n    _swap(amounts, pairs, tokens, fund());\n}\n\nfunction _swap(\n    uint256[] memory amounts,\n    address[] memory pairs,\n    address[] memory tokens,\n    address _to\n) internal virtual {\n    address outToken = tokens[tokens.length - 1];\n    uint256 startingBalance = IERC20(outToken).balanceOf(_to);\n    for (uint256 i; i < pairs.length; i++) {\n        (address input, address output) = (tokens[i], tokens[i + 1]);\n        (address token0, ) = UniswapStyleLib.sortTokens(input, output);\n\n        uint256 amountOut = amounts[i + 1];\n\n        (uint256 amount0Out, uint256 amount1Out) =\n            input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n\n        address to = i < pairs.length - 1 ? pairs[i + 1] : _to;\n        IUniswapV2Pair pair = IUniswapV2Pair(pairs[i]);\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n}\n\nfunction withdraw(\n    address withdrawalToken,\n    address recipient,\n    uint256 withdrawalAmount\n) external {\n    require(\n        isFundTransferer(msg.sender),\n        \"Contract not authorized to withdraw\"\n    );\n    IERC20(withdrawalToken).safeTransfer(recipient, withdrawalAmount);\n}\n\nfunction sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n{\n    require(tokenA != tokenB, \"Identical address!\");\n    (token0, token1) = tokenA < tokenB\n        ? (tokenA, tokenB)\n        : (tokenB, tokenA);\n    require(token0 != address(0), \"Zero address!\");\n}\n\nfunction fund() internal view returns (address) {\n    return mainCharacterCache[FUND];\n}\n\nfunction balanceOf(address guy) external view virtual override returns (uint256) {\n    return _balanceOf[guy];\n}\n"
    },
    "Duplication of Balance": {
        "desc": "It is possible to duplicate currently held `ink` or `art` within a Cauldron, thereby breaking the contract's accounting system and minting units out of thin air.\nThe `stir` function of the `Cauldron`, which can be invoked via a `Ladle` operation, caches balances in memory before decrementing and incrementing. As a result, if a transfer to self is performed, the assignment `balances[to] = balancesTo` will contain the added-to balance instead of the neutral balance.\nThis allows one to duplicate any number of `ink` or `art` units at will, thereby severely affecting the protocol's integrity. A similar attack was exploited in the third bZx hack resulting in a roughly 8 million loss.",
        "patch": "\nfunction stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n    external\n    auth\n    returns (DataTypes.Balances memory, DataTypes.Balances memory)\n{\n    (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n    (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n    require(from != to, \"Cannot transfer to self\");\n\n    if (ink > 0) {\n        require(vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n        balancesFrom.ink -= ink;\n        balancesTo.ink += ink;\n    }\n}\n"
    },
    "Can access cards of other markets": {
        "desc": "Within `RCMarket.sol` the functions `ownerOf` and `onlyTokenOwner` do not check if the `_cardId/_token` is smaller than `numberOfCards`. So it's possible to supply a larger number and access cards of other markets.\nThe most problematic seems to be `upgradeCard`. Here the check for `isMarketApproved` can be circumvented by trying to move the card via another market.\nYou can still only move cards you own.\n```solidity\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards\n        return nfthub.ownerOf(_tokenId);\n    }\nhttps://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313\n  modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\"); // _token could be higher than numberOfCards,\n        _;\n    }\nfunction upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,\n    _checkState(States.WITHDRAW);\n    require(\n        !factory.trapIfUnapproved() ||\n            factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market\n        \"Upgrade blocked\"\n    );\n    uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market\n    _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n    nfthub.withdrawWithMetadata(_tokenId);\n    emit LogNftUpgraded(_card, _tokenId);\n}\n```",
        "patch": "\nfunction ownerOf(uint256 tokenId)\n    public\n    view\n    virtual\n    override(ERC721, IRCNftHubL2)\n    returns (address)\n{\n    require(tokenId < numberOfCards, \"Card does not exist\");\n    return ERC721.ownerOf(tokenId);\n}\n\nfunction upgradeCard(uint256 _card) external onlyTokenOwner(_card) {\n    _checkState(States.WITHDRAW);\n    require(\n        !factory.trapIfUnapproved() ||\n            factory.isMarketApproved(address(this)),\n        \"Upgrade blocked\"\n    );\n    uint256 _tokenId = _card + totalNftMintCount;\n    _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n    nfthub.withdrawWithMetadata(_tokenId);\n    emit LogNftUpgraded(_card, _tokenId);\n}\n\nfunction _checkState(States currentState) internal view {\n    require(state == currentState, \"Incorrect state\");\n}\n\nfunction _transferCard(\n    address _from,\n    address _to,\n    uint256 _cardId\n) internal {\n    require(\n        _from != address(0) && _to != address(0),\n        \"Cannot send to/from zero address\"\n    );\n    uint256 _tokenId = _cardId + totalNftMintCount;\n\n    assert(nfthub.transferNft(_from, _to, _tokenId));\n    emit LogNewOwner(_cardId, _to);\n}\n\nfunction transferNft(\n    address _currentOwner,\n    address _newOwner,\n    uint256 _tokenId\n) external override returns (bool) {\n    require(isMarket[msgSender()], \"Not market\");\n    _transfer(_currentOwner, _newOwner, _tokenId);\n    return true;\n}\n\nfunction withdrawWithMetadata(uint256 tokenId) external override {\n    require(isMarket[msgSender()], \"Not market\");\n    require(\n        msgSender() == ownerOf(tokenId),\n        \"ChildMintableERC721: INVALID_TOKEN_OWNER\"\n    );\n    withdrawnTokens[tokenId] = true;\n\n    // Encoding metadata associated with tokenId & emitting event\n    emit TransferWithMetadata(\n        ownerOf(tokenId),\n        address(0),\n        tokenId,\n        this.encodeTokenMetadata(tokenId)\n    );\n\n    _burn(tokenId);\n}\n"
    },
    "Unhandled return value of transfer in `transferOut()` of Pools.sol": {
        "desc": "ERC20 implementations are not always consistent. Some implementations of transfer\u00a0and `transferFrom`\u00a0could return \u2018false\u2019 on failure instead of reverting. It is safer to wrap such calls into\u00a0`require()`\u00a0statements to handle these failures.\nThe transfer call [on L211] of `transferOut()` could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.\nFor reference, see similar finding from Consensys Diligence Audit of AAVE Protocol V2",
        "patch": "\n\n"
    },
    "Proposals can be cancelled": {
        "desc": "Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`.\nThis always passes the minority check as the proposal was approved.\nAn attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.",
        "patch": "\nfunction cancelProposal(uint oldProposalID, uint newProposalID) public {\n    require(mapPID_finalising[oldProposalID], \"Must be finalising\");\n    require(newProposalID != oldProposalID, \"New proposal ID must be different from old proposal ID\");\n    require(hasMinority(newProposalID), \"Must have minority\");\n    require(isEqual(bytes(mapPID_type[oldProposalID]), bytes(mapPID_type[newProposalID])), \"Must be same\");\n    mapPID_votes[oldProposalID] = 0;\n    emit CancelProposal(msg.sender, oldProposalID, mapPID_votes[oldProposalID], mapPID_votes[newProposalID], iVAULT(VAULT).totalWeight());\n}\n"
    },
    "User could lose underlying tokens when redeeming from the `IdleYieldSource`": {
        "desc": "The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should.\nWhen burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.",
        "patch": "\nfunction redeemToken(uint256 redeemAmount) external override nonReentrant returns (uint256 redeemedUnderlyingAsset) {\n    uint256 redeemedShare = redeemAmount; // Use redeemAmount directly\n    _burn(msg.sender, redeemedShare);\n    redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(redeemedShare);        \n    IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);\n    emit RedeemedToken(msg.sender, redeemedShare, redeemAmount);\n}\n"
    }
}