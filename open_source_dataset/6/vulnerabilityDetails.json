{
    "HighRiskFindings": {
        "ERC-721 Enumerable Spec mismatch for index of `tokenByIndex()` function": [
            "Index starts at 0 for token array, but the implementation here requires index to be greater than 0. This will prevent querying of tokens at index 0.",
            "See [reference implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3ba2a1354f8f830d5a0e711537efdbdd8bcb109e/contracts/token/ERC721/extensions/ERC721Enumerable.sol#L21).",
            "This will impact compatibility with NFT platforms that expect full conformity with ERC-721 specification.",
            "Recommend accepting 0 index by changing to `require(index >= 0 && index < TOKEN_LIMIT);`.",
            "**[dangerousfood (Meebits) commented](https://github.com/code-423n4/2021-04-meebits-findings/issues/47#issuecomment-847429104):**",
            "> Beebots indexes by 1 for whatever reason"
        ],
        "Signature malleability of EVM's `ecrecover` in `verify()`": [
            "EVM's `ecrecover` is susceptible to signature malleability, which allows replay attacks, but that is mitigated here by tracking accepted offers and canceling them (on L645) specifically to prevent replays. However, if any application logic changes, it might make signature malleability a risk for replay attacks.",
            "See [reference](https://swcregistry.io/docs/SWC-117).",
            "Recommend using [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)"
        ],
        "Arbitrary Transfer of Unowned NFTs": [
            "Due to how the market functions are structured, it is possible to arbitrarily transfer any NFT that is not owned by any address.",
            "The function in question is the `tradeValid` function invoked by `acceptTrade` before the trade is performed. It, in turn, validates the signature of a trade via `verify`, which does not account for the behavior of `ecrecover`.",
            "When `ecrecover` is invoked with an invalid signature, the zero-address is returned by it, meaning that `verify` will yield `true` for the zero-address as long as the signature provided is invalid.",
            "This can be exploited to transfer any NFT whose `idToOwner` is zero, including NFTs that have not been minted yet.",
            "Recommend an additional check be imposed within `verify` that ensures the signer is not the zero-address which will alleviate this check. For more details, consult the [EIP721 implementation by OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L53-L71)."
        ],
        "`Beebots.TradeValid()` Will Erroneously Return True When Maker Is Set To `Address(0)` and `makerIds` Are Set To The `TokenIds` of Unminted Beebot NFTs": [
            "`Beebots.TradeValid()` will erroneously return true when `maker` is set to `address(0)` and `makerIds` are set to the `tokenIds` of unminted beebot NFTs.",
            "`Beebots.verify()` returns true no matter what signature is given when signer is set to `address(0)`. This means that `BeeBots.tradeValid()` will erroneously return true when `maker` is set to `address(0)`.",
            "Finally, before an NFT has even been minted at all, it is assumed to have an owner of `address(0)` due to the `idToOwner` mapping being initialized to zero for all uninitialized slots, so an attacker can call `tradeValid()` with `maker` set to `address(0)` and `makerIds` set to the `tokenIds` of any unminted `nftIds`, and `tradeValid()` will erroneously return true.",
            "* (1) `Beebots.verify()` returns true no matter what signature is given when signer is set to `address(0)`.",
            "  * (1a) `BeeBots.verify()` does not check to ensure that signer is not `address(0)`.",
            "  * (1b) This is a problem because `ecrecover` fails silently if the signature does not match and returns zero.",
            "  * (1c) So if an attacker passes in `address(0)` as the signer, then verify will return true no matter what signature is provided, since `ecrecover` will return `address(0)`, and the signer is `address(0)`, so verify will pass.",
            "  * (1d) This means that `BeeBots.tradeValid()` will erroneously return true when maker is set to `address(0)`.",
            "* (2) Before an NFT has even been minted at all, it is assumed to have an owner of `address(0)` due to the `idToOwner` mapping being initialized to zero for all uninitialized slots",
            "  * (2a) Solidity initializes all mappings to 0 for all slots that have not yet been set.",
            "  * (2b) So for any NFT ID that has not yet been minted, the corresponding owner in the mapping `BeeBots.idToOwner` is `address(0)`, even though that NFT should not even exist.",
            "  * (2c) This means that an attacker can call `tradeValid()` with maker set to `address(0)` and makerIds set to any unminted nftIds, and `tradeValid()` will erroneously return true.",
            "(1) Recommend adding this check to `Beebots.verify()`:",
            "```require(signer != address(0), \"Cannot verify signatures from 0x0\");```",
            "(2) Recommend adding this check to `Beebots.tradeValid()`:",
            "```require(maker != address(0), \"Maker 0x0 not allowed\");```",
            "**[dangerousfood (Meebits) commented](https://github.com/code-423n4/2021-04-meebits-findings/issues/77#issuecomment-847413820):**",
            "> Wow, this exploit is absolutely stunning."
        ],
        "function `tokenByIndex` treats last index as invalid": [
            "NFT indexes start from 0:",
            "```solidity",
            "// Don't allow a zero index, start counting at 1",
            "return value.add(1);",
            "```",
            "So if there are 30 tokens, indexes would be 1-30. However, function `tokenByIndex` sets such boundaries:",
            "```solidity",
            "require(index > 0 && index < TOKEN_LIMIT);",
            "```",
            "This means that the last token (with index 30 in this case) will not be valid.",
            "Recommend using:",
            "```solidity",
            "require(index > 0 && index <= TOKEN_LIMIT);",
            "```",
            "**[dangerousfood (Meebits) commented](https://github.com/code-423n4/2021-04-meebits-findings/issues/73#issuecomment-847429563):**",
            "> Beebots is indexing by 1"
        ],
        "NFT can be minted for free after sale ended": [
            "The `getPrice()` function returned 0 after the sale ended and (```SALE_LIMIT - numSales```) NFT can be minted for free.",
            "Without documentation, it's not clear if this is the expected behavior or not. If it's unexpected, it is recommended to revert instead of returning 0. If it's expected behavior, it's possible to create a smart contract and claim all the remaining NFT front-running the regular users."
        ]
    },
    "MediumRiskFindings": {
        "Legacy Function Usage": [
            "The `withdraw` function utilizes the `transfer` invocation, which has a fixed gas stipend and can fail, especially beyond the Berlin fork, which increased the [gas costs](https://eips.ethereum.org/EIPS/eip-2929) for first-time invocations of a transfer.",
            "The EIP should be sufficient.",
            "Recommend using a safe wrapper library, such as the OpenZeppelin `Address` library's `sendValue` function, which forwards sufficient gas for the transfer regardless of the underlying OPCODE gas costs."
        ],
        "`randomIndex` is not truly random - possibility of predictably minting a specific token Id": [
            "`randomIndex' is not random. Any miner has access to these values:",
            "```solidity",
            "uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;",
            "```",
            "Non-miner attackers could also test the minting random condition until they get the ID they are looking to access.",
            "The internal variable [`indices`](https://github.com/code-423n4/2021-04-meebits/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L158) seems to be used to avoid this type of collision.",
            "While this makes it less straightforward, there is still the possibility of minting a token with a specific ID.",
            "That said, [`_addNFToken`](https://github.com/code-423n4/2021-04-meebits/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L408) is checking if the token is already owned by an address, ensuring a token can't be stolen.",
            "Refactoring as suggested below will save gas, make code easier to read and prevent reverts in rare unfortunate occasions of clashes.",
            "Recommend not generating random IDs and instead using counters. It makes the code more predictable and easier to read, avoids clashing of IDs, and reduces the need to track minted tokens."
        ],
        "instead of `call()` , `transfer()` is used to withdraw the ether": [
            "```solidity",
            "function withdraw(uint amount) external {",
            "  require(amount <= ethBalance[msg.sender]);",
            "  ethBalance[msg.sender] = ethBalance[msg.sender].sub(amount);",
            "  msg.sender.transfer(amount);",
            "  emit Withdraw(msg.sender, amount);",
            "}",
            "```",
            "To withdraw ETH, it uses `transfer()`, this transaction will fail inevitably when:",
            "1. The withdrawer smart contract does not implement a payable function.",
            "2. Withdrawer smart contract does implement a payable fallback which uses more than 2300 gas unit.",
            "3. The withdrawer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300.",
            "Recommend using `call()` to send ETH."
        ]
    }
}