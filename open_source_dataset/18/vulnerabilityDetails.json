{
    "HighRiskFindings": {
        "Reward computation is wrong": [
            "_Submitted by cmichel_",
            "The `LendingPair.accrueAccount` function distributes rewards **before** updating the cumulative supply / borrow indexes as well as the index + balance for the user (by minting supply tokens / debt).",
            "This means the percentage of the user's balance to the total is not correct as the total can be updated several times in between.",
            "```solidity",
            "function accrueAccount(address _account) public {",
            "  // distributes before updating accrual state",
            "  _distributeReward(_account);",
            "  accrue();",
            "  _accrueAccountInterest(_account);",
            "  if (_account != feeRecipient()) {",
            "    _accrueAccountInterest(feeRecipient());",
            "  }",
            "}",
            "```",
            "**Example**: Two users deposit the same amounts in the same block. Thus, after some time they should receive the same tokens.",
            "1. User A and B deposit 1000 tokens (in the same block) and are minted 1000 tokens in return. Total supply = `2000`",
            "2. Assume after 50,000 blocks, `A` calls `accrueAccount(A)` which first calls `_distributeReward`. A is paid out 1000/2000 = 50% of the 50,000 blocks reward since deposit. Afterwards, `accrue` + `_accrueAccountInterest(A)` is called and `A` is minted 200 more tokens due to supplier lending rate. The supply **totalSupply is now 2200**.",
            "3. After another 50,000 blocks, `A` calls `accrueAccount(A)` again. which first calls `_distributeReward`. A is paid out 1200/2200 = **54.5454% of the 50,000 blocks reward since deposit.**",
            "From here, you can already see that `A` receives more than 50% of the 100,000 block rewards although they deposited at the same time as `B` and didn't deposit or withdraw any funds.",
            "`B` will receive `~1000/2200 = 45%` (ignoring any new LP supply tokens minted for `A`'s second claim.)",
            "The impact is that wrong rewards will be minted users which do not represent their real fair share. Usually, users will get fewer rewards than they should receive, as their individual interest was not updated yet, but the totals (total debt and total supply) could have been updated by other accounts in between.",
            "There are two issues that both contribute to it:",
            "- total LP supply and total debt must be updated by the **total new interest** when `accrue` is called, not only increased by an **individual user**'s interest. See my other issue \"Reward computation is wrong\" that goes into more depth",
            "- Lending/borrow accrual must happen before reward distribution",
            "**[talegift (Wild Credit) acknowledged but disagreed with severity](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/116#issuecomment-880581152):**",
            " > _Assets not at direct risk, but the function of the protocol or its availability could be impacted, or **leak value** with a hypothetical attack path with stated assumptions, but **external requirements**._",
            ">",
            "> Update to severity - 2",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/116#issuecomment-890597758):**",
            " > Disagree with sponsor about severity, this is significant accounting error."
        ],
        "`LendingPair.liquidateAccount` does not accrue and update `cumulativeInterestRate`": [
            "_Submitted by cmichel_",
            "The `LendingPair.liquidateAccount` function does not accrue and update the `cumulativeInterestRate` first, it only calls `_accrueAccountInterest` which does not update and instead uses the old `cumulativeInterestRate`.",
            "The liquidatee (borrower)'s state will not be up-to-date.",
            "I could skip some interest payments by liquidating myself instead of repaying if I'm under-water.",
            "As the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.",
            "Recommend calling `accrueAccount` instead of `_accrueAccountInterest`",
            "**[talegift (Wild Credit) confirmed but disagreed with severity](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/122#issuecomment-880580414):**",
            " > _Assets not at direct risk, but the function of the protocol or its availability could be impacted, or **leak value** with a hypothetical attack path with stated assumptions, but **external requirements**._",
            ">",
            "> Update to severity - 2",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/122#issuecomment-890597983):**",
            " > No funds are lost however a user can steal \"unpaid interest\" from the protocol. Keeping high risk."
        ],
        "`LendingPair.liquidateAccount` fails if tokens are lent out": [
            "_Submitted by cmichel_",
            "The `LendingPair.liquidateAccount` function tries to pay out underlying supply tokens to the liquidator using `_safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput)` but there's no reason why there should be enough `supplyOutput` amount in the contract, the contract only ensures `minReserve`.",
            "As a result, no liquidations can be performed if all tokens are lent out.",
            "**Example:** User A supplies 1k\\$ WETH, User B supplies 1.5k\\$ DAI and borrows the ~1k\\$ WETH (only leaves `minReserve`). The ETH price drops but user B cannot be liquidated as there's not enough WETH in the pool anymore to pay out the liquidator.",
            "Recommend minting LP supply tokens to `msg.sender` instead, these are the LP supply tokens that were burnt from the borrower. This way the liquidator basically seizes the borrower's LP tokens.",
            "**[talegift (Wild Credit) confirmed but disagreed with severity](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/123#issuecomment-880580148):**",
            " > _Assets not at direct risk, but the function of the protocol or its availability could be impacted, or **leak value** with a hypothetical attack path with stated assumptions, but **external requirements**._",
            ">",
            "> Update to severity - 2",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/123#issuecomment-890598465):**",
            " > If liquidation is impossible, there's insolvency risk and that creates a risk to lose user funds. Keeping high severity."
        ]
    },
    "MediumRiskFindings": {
        "Chainlink - Use `latestRoundData` instead of `latestAnswer` to run more validations": [
            "_Submitted by a_delamo, also found by 0xRajeev, cmichel, greiart, and shw_",
            "`UniswapV3Oracle.sol` is calling `latestAnswer` to get the last WETH price. This method will return the last value, but you won't be able to check if the data is fresh.",
            "On the other hand, calling the method `latestRoundData` allow you to run some extra validations",
            "```solidity",
            "  (",
            "    roundId,",
            "    rawPrice,",
            "    ,",
            "    updateTime,",
            "    answeredInRound",
            "  ) = AggregatorV3Interface(XXXXX).latestRoundData();",
            "  require(rawPrice > 0, \"Chainlink price <= 0\");",
            "  require(updateTime != 0, \"Incomplete round\");",
            "  require(answeredInRound >= roundId, \"Stale price\");",
            "```",
            "See the chainlink [documentation](https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round) for more information.",
            "**[talegift (Wild Credit) confirmed](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/75)**",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/75#issuecomment-890584877):**",
            " > Since slate prices could have quite serious consequences, I'll bump it to medium risk."
        ],
        "`safeTransferFrom` in `TransferHelper` is not `safeTransferFrom`": [
            "_Submitted by jonah1005, also found by 0xRajeev, shw, JMukesh, and cmichel_",
            "A non standard ERC20 token would always raise error when calling `_safeTransferFrom`.  If a user creates a USDT/DAI pool and deposit into the pool he would find out there's never a counterpart deposit. See `TransferHelper.sol` [#L19](https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L19).",
            "`TransferHelper` does not uses `SafeERC20` library as the function name implies.",
            "A sample POC:",
            "```solidity",
            "usdt.functions.approve(lending_pair.address, deposit_amount).transact({'from': w3.eth.accounts[0]})",
            "lending_pair.functions.deposit(w3.eth.accounts[0], usdt.address, deposit_amount).transact({'from': w3.eth.accounts[0]})",
            "```",
            "Error Message:",
            "```solidity",
            "  Error: Transaction reverted: function returned an unexpected amount of data",
            "      at LendingPair._safeTransferFrom (contracts/TransferHelper.sol:20)",
            "      at LendingPair.deposit (contracts/LendingPair.sol:95)",
            "```",
            "Recommend using `openzeppelin` `SafeERC20` in `transferHelper` (and any other contract that uses IERC20).",
            "**[talegift (Wild Credit) confirmed](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/67)**",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/67#issuecomment-890585396):**",
            " > This can effect deposits so it's a medium risk."
        ],
        "`_wethWithdrawTo` is vulnerable re-entrancy": [
            "_Submitted by pauliax_",
            "The function `withdrawBorrowETH` invokes `_wethWithdrawTo` and later `_checkMinReserve`, however, the check of reserve is not necessary here, as function `_wethWithdrawTo` also does that after transferring the ether. However, this reserve check might be bypassed as `TransferHelper`.`_wethWithdrawTo` uses a low level call that is vulnerable to re-entrancy attacks. As this `MIN_RESERVE` sounds like an important value, you should consider preventing re-entrancy attacks here.",
            "```solidity",
            "  // Prevents division by zero and other undesirable behavior",
            "  uint public constant MIN_RESERVE = 1000;",
            "```",
            "Recommend considering using [re-entrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) on all main action functions (e.g. `deposit`, `withdraw`, `borrow`,`repay`, etc...):",
            "**[talegift (Wild Credit) confirmed](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/71)**"
        ],
        "Total LP supply & total debt accrual is wrong": [
            "_Submitted by cmichel_",
            "The total debt and total supply only increase when debt/supply is minted to the user when it should increase by the entire new interest amount on each accrual.",
            "```solidity",
            "function accrueAccount(address _account) public {",
            "  _distributeReward(_account);",
            "  // accrue only updates cumulativeInterestRate to the newInterest",
            "  // newInterest is not added to total debt or total LP supply!",
            "  accrue();",
            "  // instead total debt / total LP supply is increased here by a much smaller amount, the new interest specific for the updating user",
            "  _accrueAccountInterest(_account);",
            "  if (_account != feeRecipient()) {",
            "    _accrueAccountInterest(feeRecipient());",
            "  }",
            "}",
            "```",
            "The borrow rates (see `borrowRatePerBlock`) are wrong due to the wrong utilization ratio: The borrow utilization rate uses `LPToken.totalSupply`. Assume there's a single lender supplying \\$100k, another single borrower borrows \\$70k (ignoring irrelevant details like liquidation and the borrower not putting up collateral for the sake of the argument).",
            "After some time debt accrued and the supplier \"updates\" by calling `accrue` (but the borrower does not update), this increases the LP total supply to, say, \\$110k, while total debt is not updated. The utilization rate and thus the borrow rate is now less than before (from 70/100=70% to 70/110=63%). In reality, it should have increased as the supplier interest is only a fraction of the borrower accumulated debt. From now on less debt than expected accrues until the borrower is updated and total debt is increased.",
            "To get the correct borrow rates in the current system, every borrower and every supplier would need to be updated on every accrual which is infeasible.",
            "Recommend doing it like Compound/Aave, increase total debt and total supply on each accrual by the **total** new interest (not by the specific user's interest only).",
            "This might require a bigger refactor because the LP token is treated as a (\"lazy-evaluated\") rebasing token and the total supply is indeed the total tokens in circulation `LP.totalSupply()` and one cannot mint the new interest to all users at once in each `accrue`.",
            "That's why Compound uses an interest-bearing token and tracks total supply separately and Aave uses a real rebasing token that dynamically scales the balance in `balanceOf` and must not be updated individually for each user.",
            "**[talegift (Wild Credit) confirmed but disagreed with severity](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/115#issuecomment-880577179):**",
            " > The issue seems to only impact interest rate calculation. It doesn't allow anyone to steal the funds.",
            ">",
            "> Severity should be set to 1.",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-wildcredit-findings/issues/115#issuecomment-890597388):**",
            " > I'm making this medium risk as no funds are lost but the accounting is basically incorrect."
        ]
    }
}