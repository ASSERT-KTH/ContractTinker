{
    "HighRiskFindings": {
        "User could lose underlying tokens when redeeming from the `IdleYieldSource`": [
            "_Submitted by shw_",
            "The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should.",
            "When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.",
            "Recommend changing `redeemedShare` to `redeemAmount` at line [L131](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L129-L131).",
            "**[PierrickGT (PoolTogether) confirmed and patched](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/120#issuecomment-871284667):**",
            " > PR: https://github.com/pooltogether/idle-yield-source/pull/4"
        ],
        "`YearnV2YieldSource` wrong subtraction in withdraw": [
            "_Submitted by cmichel, also found by 0xRajeev_",
            "When withdrawing from the `vault`, one redeems `yTokens` for `token`s, thus the `token` balance of the contract should increase after withdrawal.",
            "But the contract subtracts the `currentBalance` from the `previousBalance`:",
            "```solidity",
            "uint256 yShares = _tokenToYShares(amount);",
            "uint256 previousBalance = token.balanceOf(address(this));",
            "// we accept losses to avoid being locked in the Vault (if losses happened for some reason)",
            "if(maxLosses != 0) {",
            "    vault.withdraw(yShares, address(this), maxLosses);",
            "} else {",
            "    vault.withdraw(yShares);",
            "}",
            "uint256 currentBalance = token.balanceOf(address(this));",
            "// @audit-issue this seems wrong",
            "return previousBalance.sub(currentBalance);",
            "```",
            "All vault withdrawals fail due to the integer underflow as the `previousBalance` is less than `currentBalance`. Users won't be able to get back their investment.",
            "Recommend that It should return `currentBalance > previousBalance ? currentBalance - previousBalance : 0`",
            "**[kamescg (PoolTogether) confirmed and patched](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/90#issuecomment-871932751):**",
            " > - https://github.com/pooltogether/pooltogether-yearnv2-yield-source/pull/new/fix/90",
            "> - https://github.com/pooltogether/pooltogether-yearnv2-yield-source/pull/7"
        ],
        "`BadgerYieldSource` `balanceOfToken` share calculation seems wrong": [
            "_Submitted by cmichel_",
            "When suppling to the `BadgerYieldSource`, some `amount` of `badger` is deposited to `badgerSett` and one receives `badgerSett` share tokens in return which are stored in the `balances` mapping of the user. So far this is correct.",
            "The `balanceOfToken` function should then return the redeemable balance in `badger` for the user's `badgerSett` balance.",
            "It computes it as the pro-rata share of the user balance (compared to the total-supply of `badgerSett`) on the `badger` in the vault:",
            "```solidity",
            "balances[addr].mul(",
            "  badger.balanceOf(address(badgerSett))",
            ").div(",
            "  badgerSett.totalSupply()",
            ")",
            "```",
            "However, `badger.balanceOf(address(badgerSett))` is only a small amount of badger that is deployed in the vault (\"Sett\") due to most of the capital being deployed to the _strategies_. Therefore, it under-reports the actual balance:",
            "> Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. [Badger Docs](https://badger-finance.gitbook.io/badger-finance/technical/setts/sett-contract)",
            "Any contract or user calling the `balanceOf` function will receive a value that is far lower than the actual balance.",
            "Using this value as a basis for computations will lead to further errors in the integrations.",
            "Recommend using [`badgerSett.balance()`](https://github.com/Badger-Finance/badger-system/blob/2b0ee9bd77a2cc6f875b9b984ae4dfe713bbc55c/contracts/badger-sett/Sett.sol#L126) instead of `badger.balanceOf(address(badgerSett))` to also account for \"the balance in the Sett, the Controller, and the Strategy\".",
            "**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/84)**"
        ],
        "withdraw timelock can be circumvented": [
            "_Submitted by cmichel_",
            "One can withdraw the entire `PrizePool` deposit by circumventing the timelock.",
            "Assume the user has no credits for ease of computation:",
            "- user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This \"mints\" an equivalent `amount` of `timelock` and resets `_unlockTimestamps[user] = timestamp = blockTime + lockDuration`.",
            "- user calls `withdrawWithTimelockFrom(user, amount=0)` again but this time withdrawing `0` amount. This will return a `lockDuration` of `0` and thus `unlockTimestamp = blockTime`. The inner `_mintTimelock` now resets `_unlockTimestamps[user] = unlockTimestamp`",
            "- As `if (timestamp <= _currentTime()) ` is true, the full users amount is now transferred out to the user in the `_sweepTimelockBalances` call.",
            "Users don't need to wait for their deposit to contribute their fair share to the prize pool.",
            "They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol.",
            "It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.",
            "Recommend that the unlock timestamp should be increased by duration each time, instead of being reset to the duration.",
            "**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/91#issuecomment-868089158):**",
            "> Mitigation:",
            ">",
            "> If a user's timelock balance is non-zero, the prize strategy rejects the ticket burn."
        ],
        "`IdleYieldSource` doesn't use mantissa calculations": [
            "_Submitted by tensors_",
            "Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.",
            "For example, say I deposit 1 token, expecting 1 share in return. On [L95](https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L95), if the `totalUnderlyingAssets` is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.",
            "Recommend  implementing mantissa calculations like in the contract for the AAVE  yield.",
            "**[PierrickGT (PoolTogether) confirmed and patched](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/103#issuecomment-873072563):**",
            " > PR: https://github.com/pooltogether/idle-yield-source/pull/5"
        ]
    },
    "MediumRiskFindings": {
        "`safeApprove()` for Yearn Vault may revert preventing deposits causing DoS": [
            "_Submitted by 0xRajeev, also found by pauliax_",
            "The `_depositInVault()` function for Yearn yield source uses ERC20 `safeApprove()` from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract\u2019s token balance.",
            "However, the\u00a0`safeApprove` function\u00a0prevents changing an allowance between non-zero values\u00a0to mitigate a\u00a0possible front-running attack. It reverts if that is the case. Instead, the\u00a0`safeIncreaseAllowance`\u00a0and\u00a0`safeDecreaseAllowance`\u00a0functions should be used. Comment from the OZ library for this function:",
            "> \u201c// `safeApprove` should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and \u2018safeDecreaseAllowance'\"",
            "If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then `safeApprove()` will revert causing the user\u2019s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible. See [similar Medium-severity finding M03](https://blog.openzeppelin.com/1inch-exchange-audit/).",
            "Recommend using `safeIncreaseAllowance()`\u00a0function instead of `safeApprove()`.",
            "**[kamescg (PoolTogether) confirmed and patched](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/71#issuecomment-871928392):**",
            "> - https://github.com/pooltogether/pooltogether-yearnv2-yield-source/pull/new/fix/71",
            "> - https://github.com/jmonteer/pooltogether-yearnv2-yield-source/pull/6"
        ],
        "Return values of ERC20 `transfer` and `transferFrom` are unchecked": [
            "_Submitted by shw, gpersoon, JMukesh, also found by a_delamo and cmichel_",
            "In the contracts `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked to be `true`, which could be `false` if the transferred tokens are not ERC20-compliant (e.g., `BADGER`). In that case, the transfer fails without being noticed by the calling contract.",
            "If warden's understanding of the `BadgerYieldSource` is correct, the `badger` variable should be the `BADGER` token at address `0x3472a5a71965499acd81997a54bba8d852c6e53d`. However, this implementation of `BADGER` is not ERC20-compliant, which returns `false` when the sender does not have enough token to transfer (both for `transfer` and `transferFrom`). See the [source code on Etherscan](https://etherscan.io/address/0x3472a5a71965499acd81997a54bba8d852c6e53d#code) (at line 226) for more details.",
            "Recommend using the [`SafeERC20` library implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from Openzeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.",
            "**[kamescg (PoolTogether) confirmed and patched](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/112#issuecomment-870060136):**",
            "> Sushi",
            "> - https://github.com/pooltogether/sushi-pooltogether/pull/new/fix/112",
            "> - https://github.com/pooltogether/sushi-pooltogether/pull/11",
            ">",
            "> Badger",
            "> - https://github.com/pooltogether/badger-yield-source/pull/new/fix/112",
            "> - https://github.com/pooltogether/badger-yield-source/pull/2",
            "**[dmvt (judge) commented](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/112#issuecomment-890403952):**",
            " > Sponsor has repeatedly stated in duplicate issues that: \"It's more of a 1 (Low Risk) because the subsequent deposit calls will fail. There is no advantage to be gained; the logic is simply poor.\"",
            ">",
            "> I disagree with this assessment. The function(s) in question do not immediately call deposit or another function that would cause a revert. In fact the balances are updated:",
            "```solidity",
            "  balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);",
            "  badger.transfer(msg.sender, badgerBalanceDiff);",
            "  return (badgerBalanceDiff);",
            "```",
            "> The impact that this would have on the rest of the system is substantial, including causing incorrect balances to be returned and potentially lost funds.",
            ">",
            "> That said, I do not think this is very likely and so high severity seems excessive here. Im adjusting all of these reports to Medium Risk given that lower likelihood."
        ],
        "`SafeMath` not completely used in yield source contracts": [
            "_Submitted by shw, also found by cmichel_",
            "`SafeMath` is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow:",
            "1. [line 78](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L78) in `SushiYieldSource`",
            "2. [line 67](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L67) in `BadgerYieldSource`",
            "3. line [91](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L91) and [98](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L98) in `IdleYieldSource`",
            "Recommend using the `SafeMath` library functions in the above lines.",
            "**[asselstine (PoolTogether) confirmed and disagreed with severity](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/114#issuecomment-868022899):**",
            " > While the arithmetic ceiling is quite high, if an overflow occurred this would significantly disrupt the yield sources.  I'd qualify this issue higher as `2 (Med Risk)`.",
            "**[dmvt (judge) commented](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/114#issuecomment-904646481):**",
            " > I agree with the sponsor's risk evaluation. Increasing to medium."
        ],
        "The assumption that operator == to (user) may not hold leading to failed timelock deposits": [
            "_Submitted by 0xRajeev_",
            "The contract uses `_msgSender()` to denote an operator who is operating on behalf of the user. This is typically used for meta-transactions where the operator is an intermediary/relayer who may facilitate gas-less transactions on behalf of the user. They may be the same address but it is safer to assume that they may not be.",
            "While the code handles this separation of role in most cases, it misses doing so in `timelockDepositTo()` function where it accounts the `_timelockBalances` to the operator address instead of the user specified `to` address. It assumes they are the same. The corresponding usage in `_mintTimelock()` which is called from `withdrawWithTimelockFrom()` uses the user specified 'from' address and not the `_msgSender()`. Therefore the corresponding usage in `timelockDepositTo()` should be the same.",
            "In the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, the timelock deposits and withdrawals are made to/from different addresses and so the deposits of timelocked tokens will fail because the operator\u2019s address does not have the required amount of `_timelockBalances`.",
            "Recommend changing `operator` to `from` on [L281](https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L281) of `timelockDepositTo()` and specifying the scenarios where the role of the operator is applicable and document/implement those accordingly.",
            "**[asselstine (PoolTogether) disputed](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/51#issuecomment-868891482):**",
            " > In the function `timelockDepositTo()` the msg.sender is using their timelocked funds to re-enter the pool.  They can only spend their own funds; they should not be able to spend other user's funds.",
            ">",
            "> The warden is saying the `timelockDepositTo` should be callable by anyone and allow them to transfer other user's funds from the timelock back into tickets.  This actually introduces an attack vector.",
            "**[dmvt (judge) commented](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/51#issuecomment-907497531):**",
            " > I think sponsor is misunderstanding warden's concern here. The issue is not that `msg.sender` is being checked, but that `_msgSender` is being checked. Happy to discuss this more if sponsor still disagrees, but I think the concern raised is valid."
        ],
        "Actual yield source check on address will succeed for non-existent contract": [
            "_Submitted by 0xRajeev_",
            "Low-level calls `call`/`delegatecall`/`staticcall`\u00a0return\u00a0true\u00a0even if the account called is non-existent (per EVM design). [Solidity documentation](https://docs.soliditylang.org/en/v0.8.6/control-structures.html#error-handling-assert-require-revert-and-exceptions) warns:",
            "> \"The low-level functions\u00a0call, delegatecall\u00a0and staticcall return\u00a0true\u00a0as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\u201d",
            "The `staticcall` here will return True even if the `_yieldSource` contract doesn't exist at any incorrect-but-not-zero address, e.g. EOA address, used during initialization by accident.",
            "The hack, as commented, to check if it\u2019s an actual yield source contract, will fail if the address is indeed a contract account which doesn\u2019t implement the `depositToken` function. However, if the address is that of an EOA account, the check will pass here but will revert in all future calls to the yield source forcing contract redeployment after the pool is active. Users will not be able to interact with the pool and abandon it.",
            "Recommend that a contract existence check should be performed on `_yieldSource` prior to the depositToken function existence hack for determining yield source contract.",
            "**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/59)**"
        ],
        "`YieldSourcePrizePool_canAwardExternal` does not work": [
            "_Submitted by cmichel_",
            "The idea of `YieldSourcePrizePool_canAwardExternal` seems to be to disallow awarding the interest-bearing token of the yield source, like aTokens, cTokens, yTokens.",
            "> \"@dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The prize strategy should not be allowed to move those tokens.\"",
            "However, the code checks `_externalToken != address(yieldSource)` where `yieldSource` is the actual yield strategy contract and not the strategy's interest-bearing token.",
            "Note that the `yieldSource` is usually not even a token contract except for `ATokenYieldSource` and `YearnV2YieldSource`.",
            "The `_canAwardExternal` does not work as expected. It might be possible to award the interest-bearing token which would lead to errors and loss of funds when trying to redeem underlying.",
            "There doesn't seem to be a function to return the interest-bearing token. It needs to be added, similar to `depositToken()` which retrieves the underlying token.",
            "**[asselstine (PoolTogether) acknowledged](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/92#issuecomment-868859317):**",
            " > This is an interesting one:",
            ">",
            "> - the yield source interface does not require the deposit be tokenized; the implementation is entirely up to the yield source.",
            "> - the _canAwardExternal is a legacy of older code.  Since it had to be included it was set to assume the yield source was tokenized.",
            ">",
            "> Since yield sources are audited and analyzed, I think this is a pretty low risk.  Additionally, not all of the yield sources are tokenized (Badger and Sushi are not), so it isn't a risk for them.",
            ">",
            "> We could have `canAwardExternal` on the yield source itself, but it would add gas overhead.",
            ">",
            "**[aodhgan (PoolTogether) commented](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/92#issuecomment-873106239):**",
            " > Could we add an check -",
            "> `",
            "> function _canAwardExternal(address _externalToken) internal override view returns (bool) {",
            "> return _externalToken != address(yieldSource) && _externalToken != address(yieldSource.depositToken())",
            "> }`",
            "**[asselstine (PoolTogether) commented](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/92#issuecomment-874342323):**",
            " > We could add another check, but it's still arbitrary.  The point is that the yield source knows what token the prize pool may or may not hold, so without asking the yield source it's just a guess.",
            ">",
            "> Let's leave it as-is"
        ],
        "Using `transferFrom` on ERC721 tokens": [
            "_Submitted by shw_",
            "In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of `safeTransferFrom`. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.",
            "Recommend consider changing `transferFrom` to `safeTransferFrom` at line 602. However, it could introduce a DoS attack vector if any winner maliciously rejects the received ERC721 tokens to make the others unable to get their awards. Possible mitigations are to use a `try/catch` statement to handle error cases separately or provide a function for the pool owner to remove malicious winners manually if this happens.",
            "**[asselstine (PoolTogether) confirmed and disagreed with severity](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/115#issuecomment-868021913):**",
            " > This issue poses no risk to the Prize Pool, so it's more of a `1 (Low Risk` IMO.",
            ">",
            "> This is just about triggering a callback on the ERC721 recipient.  We omitted it originally because we didn't want a revert on the callback to DoS the prize pool.",
            ">",
            "> However, to respect the interface it makes sense to implement it fully.  That being said, if it does throw we must ignore it to prevent DoS attacks.",
            "**[dmvt (judge) commented](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/115#issuecomment-907507608):**",
            " > I agree with the medium risk rating provided by the warden."
        ]
    }
}