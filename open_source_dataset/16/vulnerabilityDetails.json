{
    "HighRiskFindings": {
        "Wrong trading pricing calculations": [
            "_Submitted by 0xsanson, also found by shw_",
            "In the `Pricing` contract, an agent can manipulate the trading prices by spamming a high amount of trades.",
            "Indeed an agent can create a high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls `Trader.executeTrade`; now every order calls a `Pricing.recordTrade` using the arbitrary price set by the agent.",
            "Since the trades are all made in the same hour, by the way `hourlyTracerPrices[currentHour]` is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the `fundingRates` and the `fairPrice`, allowing a malicious agent the ability to manipulate the market.",
            "Recommend passing the `fillAmount` parameter to `recordTrade(...)`, and calculate `hourlyTracerPrices[currentHour].trades` summing `fillAmount` instead of 1 every trade.",
            "**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/119#issuecomment-873747695):**",
            " > Issue is valid, and there appear to be a few other issues that reference similar problems.",
            ">",
            "> The Trader contract will have a whitelist allowing only select relayers to push orders on chain. As long as off chain order books have sufficient liquidity, this issue is then mitigated as users can't just arbitrarily match orders and send them in, they must be matched on a book with liquidity. To alter the price you would then need to eat through significant liquidity (increasing the cost of this attack)."
        ],
        "Use of incorrect index leads to incorrect updation of funding rates": [
            "_Submitted by 0xRajeev_",
            "The `updateFundingRate()` function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of `[currentFundingIndex]` which has been updated since the previous call to this function while it should really be using `[currentFundingIndex-1]` to reference the previous funding rate.",
            "The impact of this, is that the cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and the protocol takes a reputation hit.",
            "Recommend using `[currentFundingIndex-1]` for non-zero values of `currentFundingIndex` to get the value updated in the previous call on lines L155 and L159 of `Pricing.sol`.",
            "**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/74#issuecomment-873752562):**",
            " > Confirmed as an index issue with funding rate \ud83d\udc4d"
        ],
        "Malicious owner can drain the market at any time using `SafetyWithdraw`": [
            "_Submitted by 0xRajeev, also found by pauliax and gpersoon_",
            "The `withdrawERC20Token()` in `SafetyWithdraw` inherited in `TracerPerpetualSwaps` is presumably a guarded launch emergency withdrawal mechanism. However, given the trust model where the market creator/owner is potentially untrusted/malicious, this is a dangerous approach to emergency withdrawal in the context of guarded launch.",
            "Alternatively, if this is meant for the owner to withdraw \u201cexternal\u201d ERC20 tokens mistakenly deposited to the Tracer market, then the function should exclude `tracerQuoteToken` from being the `tokenAddress` that can be used as a parameter to `withdrawERC20Token()`.",
            "The impact of this is that, if a malicious owner of a market withdraws/rugs all `tracerQuoteToken`s deposited at any time after market launch, all users lose deposits and the protocol takes a reputational hit and has to refund the users from treasury.",
            "Therefor, it is recommended that, for a guarded launch circuit breaker, design a pause/unpause feature where deposits are paused (in emergency situations) but withdrawals are allowed by the depositors themselves instead of the owner. Alternatively, if this is meant to be for removing external ERC20 tokens accidentally deposited to market, exclude the `tracerQuoteToken` from being given as the `tokenAddress`.",
            "**[raymogg (Tracer) confirmed but suggested a severity of 2 ](https://github.com/code-423n4/2021-06-tracer-findings/issues/81#issuecomment-873752133):**",
            " > The only reason for the dispute on severity is that as part of the security model, the owner can manipulate the market in other ways (such as changing the oracle being used), so this trust assumption over the owner already exists. For this reason the team thinks this issue is closer to a medium",
            ">",
            "> This however is a good issue as it is not the greatest circuit breaking mechanism, and as noted in #7 can reflect badly on the project without the exploit being used. The mechanism is being removed and replaced with more structured circuit breaker.",
            "**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/81#issuecomment-882110087):**",
            " > Marking this as high risk, as regardless of the owner manipulating in other ways, the threat persists."
        ],
        "Logic error in fee subtraction": [
            "_Submitted by 0xsanson_",
            "In `LibBalances.applyTrade()`, we need to collect a fee from the trade. However, the current code subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see `TracerPerpetualSwaps.sol` L272).",
            "This issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.",
            "Recommend changing `+fee` to `-fee` in the [highlighted line](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L187).",
            "**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/127#issuecomment-873778933):**",
            " > Valid issue \ud83d\udc4d"
        ],
        "Insurance slippage reimbursement can be used to steal insurance fund": [
            "_Submitted by cmichel_",
            "The `Liquidation` contract allows the liquidator to submit \"bad\" trade orders and the insurance reimburses them from the insurance fund, see `Liquidation.claimReceipt`.",
            "The function can be called with an `orders` array, which does not check for duplicate orders.",
            "An attacker can abuse this to make a profit by liquidating themselves, making a small bad trade and repeatedly submitting this bad trade for slippage reimbursement.",
            "**Example**:",
            "- Attacker uses two accounts, one as the liquidator and one as the liquidatee.",
            "- They run some high-leverage trades such that the liquidatee gets liquidated with the next price update. (If not cash out and make a profit this way through trading, and try again.)",
            "- Liquidator liquidates liquidatee",
            "- They now do two trades:",
            "  - One \"good\" trade at the market price that fills 99% of the liquidation amount. The slippage protection should not kick in for this trade",
            "  - One \"bad\" trade at a horrible market price that fills only 1% of the liquidation amount. This way the slippage protection kicks in for this trade",
            "- The liquidator now calls `claimReceipt(orders)` where `orders` is an array that contains many duplicates of the \"bad\" trade, for example 100 times. The `calcUnitsSold` function will return `unitsSold = receipt.amountLiquidated` and a bad `avgPrice`. They are now reimbursed the price difference on the full liquidation amount (instead of only on 1% of it) making an overall profit",
            "This can be repeated until the insurance fund is drained.",
            "The attacker has an incentive to do this attack as it's profitable and the insurance fund will be completely drained.",
            "Recommend disallowing duplicate orders in the `orders` argument of `claimReceipt`. This should make the attack at least unprofitable, but it could still be a griefing attack.",
            "A quick way to ensure that `orders` does not contain duplicates is by having liquidators submit the orders in a sorted way (by order ID) and then checking in the `calcUnitsSold` `for` loop that the current order ID is strictly greater than the previous one.",
            "**[BenjaminPatch (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/105#issuecomment-873780483):**",
            " > Valid issue. The recommended mitigation step would also work. :+1:"
        ],
        "Wrong price scale for `GasOracle`": [
            "_Submitted by cmichel_",
            "The `GasOracle` uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.",
            "However, the scaling depends on the underlying decimals of the two oracles and could be anything.",
            "But the code assumes it's in 18 decimals.",
            "> \"Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\"",
            "There is a `toWad` function that seems to involve scaling but it is never used.",
            "The impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported.",
            "Recommend checking `chainlink.decimals()` to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the `latestAnswer` function always returns the answer in 18 decimals.",
            "**[raymogg (Tracer) confirmed and disagreed with severity](https://github.com/code-423n4/2021-06-tracer-findings/issues/93#issuecomment-873750451):**",
            " > Disagree with severity as while the statement that the underlying decimals of the oracles could be anything, we will be using production Chainlink feeds for which the decimals are known at the time of deploy.",
            ">",
            "> This is still however an issue as you don't want someone using different oracles (eg non Chainlink) that have different underlying decimals and not realising that this contract will not support that.",
            "**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/93#issuecomment-882123137):**",
            " > Marking this a high-risk issue as it poses a big threat to users deploying their own markets"
        ]
    },
    "MediumRiskFindings": {
        "Use of deprecated Chainlink API": [
            "_Submitted by 0xRajeev, also found by a_delamo, cmichel and shw_",
            "The contracts use Chainlink\u2019s deprecated API `latestAnswer()`. Such functions might suddenly stop working if Chainlink stopped supporting deprecated APIs.",
            "The impact is that, if the deprecated API stops working, prices cannot be obtained, the protocol stops and contracts have to be redeployed.",
            "Recommend using V3 [interface functions](https://docs.chain.link/docs/price-feeds-api-reference/).",
            "**[raymogg (Tracer) confirmed in a separate issue](https://github.com/code-423n4/2021-06-tracer-findings/issues/145)**"
        ],
        "No check `transferFrom()` return value": [
            "_Submitted by s1m0, also found by pauliax, shw, 0xRajeev, JMukesh, Lucius and cmichel_",
            "The smart contract doesn't check the return value of `token.transfer()` and `token.transferFrom()`, some erc20 token might not revert in case of error but return false.",
            "In the [TracerPerpetualSwaps:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and [Insurance:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free. See issue page for other places.",
            "Recommend wrapping the call into a `require()` or using openzeppelin's [SafeERC20 library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol).",
            "**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/115)**"
        ],
        "Deflationary tokens are not supported": [
            "_Submitted by cmichel, also found by s1m0 and 0xRajeev_",
            "There are ERC20 tokens that may make certain customizations to their ERC20 contracts.",
            "One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.",
            "The `deposit()` functions of `Insurance` and `TracerPerpetualSwaps` assume that the external ERC20 balance of the contract increases by the same amount as the `amount` parameter of the `transferFrom`.",
            "The user is credited the full amount without the taxes (`userBalance.position.quote`).",
            "Recommend as one possible mitigation, measuring the asset change right before and after the asset-transferring functions.",
            "**[raymogg (Tracer) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-tracer-findings/issues/104#issuecomment-873757118):**",
            " > Most likely not a medium risk as you can do a lot more nasty things than just use rebasing tokens. Since the owner of a market can set their own quote token, this token could be a token they control the supply of allowing them to arbitrarily transfer tokens between accounts, etc.",
            ">",
            "> As such, this sort of falls outside of our trust model. Market creators should use tokens that behave as \"standard\" ERC20s. We will make a not that rebasing and deflationary tokens should not be used as quote tokens without weird behaviour.",
            ">",
            "> Would be better as a low or informational issue due to this.",
            "**[cemozerr (Judge) downgraded severity from 2 to 1](https://github.com/code-423n4/2021-06-tracer-findings/issues/104#issuecomment-882104304):**",
            " > Marking this as low risk as it seems to fall outside of the trust model, yet important enough to communicate to users explicitly."
        ],
        "Underflow problems occurring when a token has >18 decimals": [
            "_Submitted by tensors, also found by s1m0_",
            "The contracts assume that all tokens will have <=18 decimals. This isn't necessarily a problem if the Tracer team is the only people deploying the contracts and they keep it in mind. But, If the contracts are to be deployed by other people, this assumption should be made explicit and hard-coded.",
            "We can see that the scaler computations will underflow and be defined when it should not be In [L220-L232](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L220-L232).",
            "Recommend writing a require check that ensures `tokenDecimals <= 18` before running the above functions.",
            "**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/116#issuecomment-873755853):**",
            " > Valid issue and makes sense as a medium.",
            ">",
            "> Suggested mitigation will be implemented."
        ],
        "Add reentrancy protections on function `executeTrade`": [
            "_Submitted by shw, also found by 0xRajeev_",
            "As written in the to-do comments, reentrancy could happen in the `executeTrade` function of `Trader` since the `makeOrder.market` can be a user-controlled external contract. See [L121-L126](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L121-L126) in `Trader.sol`.",
            "Recommend adding a reentrancy guard (e.g., the [implementation from OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)) to prevent the users from reentering critical functions.",
            "**[raymogg (Tracer) disputed](https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-874405296):**",
            " > Disputing just as while this is important, its quite explicitly stated in the todo comment and as such is already known by the team as a potential issue.",
            ">",
            "> Realistically shouldn't be too much of a problem with whitelisting of the trader.",
            "**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-882105114):**",
            " > Marking this as medium risk as, regardless of being noted by the team, still poses a security threat.",
            "**[OsmanBran (Tracer) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-874405296):**",
            " > Duplicate of [#72](https://github.com/code-423n4/2021-06-tracer-findings/issues/72)"
        ],
        "Single-step process for critical ownership transfer": [
            "_Submitted by 0xRajeev_",
            "The `Tracer Perpetuals Factory` contract is arguably the most critical contract in the project given that it deploys all the markets. The ownership of this contract is transferred to `_governance address`, i.e. TracerDAO, in the constructor. This critical address transfer in one-step is very risky because it is irrecoverable from any mistakes.",
            "The impact is that, if an incorrect address (e.g. one for which the private key is not known) is used accidentally, then it prevents the use of all the `onlyOwner()` functions forever, which includes the changing of various deployer contract addresses and market approvals. This use of an incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing `onlyOwner()` function call, it will force the redeployment of the `factory` contract and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in markets and incur a significant reputational damage. See [issue page](https://github.com/code-423n4/2021-06-tracer-findings/issues/43) for proof of concept.",
            "Recommend retaining the deployer ownership in the constructor and then using a two-step address change to `_governance` address separately using setter functions:",
            "1) Approve a new address as a `pendingOwner`",
            "2) A transaction from the `pendingOwner` (TracerDAO) address claims the pending ownership change.",
            "This mitigates risk because if an incorrect address is used in step (1), then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.",
            "**[raymogg (Tracer) acknowledged](https://github.com/code-423n4/2021-06-tracer-findings/issues/43#issuecomment-873762658):**",
            " > Correct that having the owner be set to a wrong address could be detrimental, however for the first deploy of the factory, this will be owned by the DAO and will be easy to validate on deployment.",
            ">",
            "> Subsequent ownership transfers will be done via DAO proposal, and will have many eyes across them (due to them being a public Tracer DAO proposal) before function execution happens.",
            ">",
            "> For this reason it seems like a lot of overhead to have a two step process for this. Not withstanding that the issue you mention could still be possible"
        ],
        "Malicious owner can arbitrarily change fee to any % value": [
            "_Submitted by 0xRajeev_",
            "The Tracer protocol like any other allows market creators to charge fees for trades. However, a malicious/greedy owner can arbitrarily change fee to any % value and without an event to observe this change or a timelock to react, there is no easy way for users to monitor this via front-end or off-chain monitoring tools.",
            "The impact is that, if the users are trading on a market with 0.1% fees and the owner suddenly changes this to 100%, the users realise this only after their trades are executed. Market loses confidence. Protocol takes a reputational hit.",
            "See similar Medium-severity finding in [ConsenSys's Audit of 1inch Liquidity Protocol](https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing)",
            "Recommend implementing an `Emit` event, and providing a timelock for users to react and establish an upper threshold for fees that is decided across markets by governance.",
            "**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/66#issuecomment-873760964):**",
            " > Like the idea of having a timelock for any update parameter update that immediately affects traders"
        ],
        "Missing events for critical parameter changing operations by owner": [
            "_Submitted by 0xRajeev_",
            "The owner of `TracerPerpetualSwaps` contract, who is potentially untrusted as per specification, can change the market critical parameters such as the addresses of the `Liquidation`/`Pricing`/`Insurance`/`GasOracle`/`FeeReceiver` and also critical values such as  `feeRate`, `maxLeverage`, `fundingRateSensitivity`, `deleveragingCliff`, `lowestMaxLeverage`, `insurancePoolSwitchStage` and whitelisting.",
            "None of these setter functions emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.",
            "The impact of this is that, if a malicious owner changes the critical addresses or values that significantly change the security posture/perception of the protocol. No events are emitted and users lose funds/confidence. The protocol takes a reputation hit.",
            "See similar high-severity finding in [OpenZeppelin\u2019s Audit of Audius](https://blog.openzeppelin.com/audius-contracts-audit/#high) and medium-severity finding [OpenZeppelin\u2019s Audit of UMA Phase 4](https://blog.openzeppelin.com/uma-audit-phase-4/).",
            "Recommend to consider emitting events when these addresses/values are updated. This will be more transparent and it will make it easier to keep track of the status of the system.",
            "**[raymogg (Tracer) marked as duplicate of another (confirmed issue)](https://github.com/code-423n4/2021-06-tracer-findings/issues/64#issuecomment-873760825):**",
            " > Duplicate of #66",
            "**[cemozerr (Judge) reopened and removed duplicate label](https://github.com/code-423n4/2021-06-tracer-findings/issues/64#issuecomment-882106845):**",
            " > Opening this issue as the event emission seems to be separate from the arbitrarily changing of the values."
        ],
        "Wrong funding index in settle when no base?": [
            "_Submitted by cmichel_",
            "The `TracerPerpetualSwaps.settle` function updates the user's last index to `currentGlobalFundingIndex`, however a comment states:",
            "> \"// Note: global rates reference the last fully established rate (hence the -1), and not the current global rate. User rates reference the last saved user rate\"",
            "The code for the `else` branch also updates the last index to `currentGlobalFundingIndex - 1` instead of `currentGlobalFundingIndex`.",
            "```solidity",
            "if (accountBalance.position.base == 0) {",
            "    // set to the last fully established index",
            "    // @audit shouldn't this be global - 1 like below?",
            "    accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;",
            "    accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();",
            "}",
            "```",
            "The impact is that it might be possible for first-time depositors to skip having to pay the first funding rate period as the `accountLastUpdatedIndex + 1 < currentGlobalFundingIndex` check will still return `false` when the funding rates are updated the next time.",
            "Recommend to check if setting it to `currentGlobalFundingIndex` or to `currentGlobalFundingIndex - 1` is correct.",
            "**[raymogg (Tracer) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-tracer-findings/issues/106)**"
        ],
        "`prb-math` not audited": [
            "_Submitted by gpersoon_",
            "The library [`prb-math` documents](// https://github.com/hifi-finance/prb-math#security) have not been audited by a security researcher.  This means its more risky to rely on this library.",
            "Recommend considering (crowdsourcing) an audit for `prb-math`.",
            "**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/11)**"
        ],
        "Claim liquidation escrow": [
            "_Submitted by gpersoon_",
            "A liquidator can always claim the liquidation escrow in the following way:",
            "- create a second account",
            "- setup a complimentary trade in that second account, which will result in a large slippage when executed",
            "- call `executeTrade` (which everyone can call), to execute a trade between his own two accounts with a large slippage",
            "- the slippage doesn't hurt because the liquidator owns both accounts",
            "- call `claimReceipt` with the receiptId of the executed order, within the required period (e.g. 15 minutes)",
            "[L67](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67)",
            "```solidity",
            "function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {",
            "```",
            "[L394](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L394)",
            "```solidity",
            "function claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {",
            "```",
            "Recommend to perhaps limit who can call `executeTrade`.",
            "**[raymogg (Tracer) acknowledged and confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/2#issuecomment-873774429):**",
            " > Valid issue which would allow someone to get reimbursed for slippage against themselves.",
            ">",
            "> The Trader contract will have whitelisted relayers added to prevent issues like this (similar to #119)"
        ],
        "avoid paying insurance": [
            "_Submitted by gpersoon_",
            "It's possible to avoid paying insurance in the following way:",
            "- once per hour (at the right moment), do the following:",
            "1. using a flash loan, or with a large amount of tokens, call `deposit` of `Insurance.sol` to make sure that the pool is sufficiently filled (`poolHoldings` > `poolTarget`)",
            "2. call the function `executeTrade` of Trader`.sol` with a minimal trade (possibly of value 0, see finding \"`executeTrade` with same trades\")",
            "3. `executeTrade` calls `matchOrders`, which calls `recordTrade`",
            "4. `recordTrade` calls `updateFundingRate()`;   (once per hour, so you have to be sure you do it in time before other trades trigger this)",
            "5. `updateFundingRate` calls `getPoolFundingRate`",
            "6. `getPoolFundingRate` determines the insurance rate, but because the insurance pool is sufficiently full (due to the flash loan), the rate is 0",
            "7. `updateFundingRate` stores the 0 rate via `setInsuranceFundingRate`  (which is used later on to calculate the amounts for the insurances)",
            "8. withdraw from the Insurance and pay back the flash loan",
            "The insurance rates are 0 now and no-one pays insurance. The gas costs relative to the insurance costs + the flash loan fees determine if this is an economically viable attack. Otherwise it is still a grief attack.",
            "This will probably be detected pretty soon because the insurance pool will stay empty. However its difficult to prevent.",
            "See issue page for code referenced in proof of concept.",
            "Recommend setting a timelock on withdrawing insurance.",
            "**[raymogg (Tracer) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-tracer-findings/issues/30#issuecomment-873763520):**",
            " > Really like this exploit idea. Currently this is possible since the Trader is not whitelisted (eg there is no whitelisted relayer address). With this added, this exploit is no longer possible as only off chain relayers can place orders with the trader.",
            ">",
            "> Disagree with the severity mainly due to the fact that executing this exploit once would only cause insurance funding to not be paid for a single hour. For insurance funding to never be paid, you would have to time this transaction as the first transaction on each and every hour. This would quickly be noticed. The only affect on this would be insurance depositors miss interest payments for a few periods.",
            "**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/30#issuecomment-882109332):**",
            " > Marking this as medium risk as a front-runner could keep doing this for not paying any funding using a bot."
        ],
        "Trader orders can be front-run and users can be denied from trading": [
            "_Submitted by cmichel, also found by gpersoon and tensors_",
            "The `Trader` contract accepts two signed orders and tries to match them. Once they are matched and become filled, they can therefore not be matched against other orders anymore.",
            "This allows for a griefing attack where an attacker can deny any other user from trading by observing the mempool and front-running their trades by creating their own order and match it against the counter order instead.",
            "In this way, a trader can be denied from trading. The cost of the griefing attack is that the trader has to match the order themselves, however depending on the liquidity of the order book and the spread, they might be able to do the counter-trade again afterwards, basically just paying the fees.",
            "It could be useful if the attacker is a liquidator and is stopping a user who is close to liquidation from becoming liquid again.",
            "This seems hard to circumvent in the current design. If the order book is also off-chain, the `executeTrade` could also be a bot-only function.",
            "**[raymogg (Tracer) disputed (in duplicate)](https://github.com/code-423n4/2021-06-tracer-findings/issues/123#issuecomment-873755673)**",
            "> Marked as a dispute as this is not really an issue. Tracer will initially maintain an off chain order book that is the entry point for users to make orders (and for market makers to interact with).",
            ">",
            "> Orders only get propagated on chain once they have been matched, and they will only be propagated on chain by whitelisted relayers. As such nobody can arbitrarily frontrun the orders with their own.",
            "**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/123#issuecomment-882119567):**",
            " > Currently not seeing a whitelisted relayer functionality, so marking this a valid medium risk issue."
        ]
    }
}