{
    "HighRiskFindings": {
        "UniswapConfig getters return wrong token config if token config does not exist": [
            "The `UniswapConfig.getTokenConfigBySymbolHash` function does not work as `getSymbolHashIndex` returns `0` if there is no config token for that symbol (uninitialized map value), but the outer function implements the non-existence check with `-1`.",
            "The same issue occurs also for:",
            "- `getTokenConfigByCToken`",
            "- `getTokenConfigByUnderlying`",
            "When encountering a non-existent token config, it will always return the token config of the **first index** (index 0) which is a valid token config for a completely different token.",
            "This leads to wrong oracle prices for the actual token which could in the worst case be used to borrow more tokens at a lower price or borrow more tokens by having a higher collateral value, essentially allowing undercollateralized loans that cannot be liquidated.",
            "Recommend fixing the non-existence check.",
            "**[ghoul-sol (Based Loans) confirmed](https://github.com/code-423n4/2021-04-basedloans-findings/issues/37#issuecomment-835476066):**",
            "> Addressed in **[this PR](https://github.com/code-423n4/2021-04-basedloans-findings/issues/37#issuecomment-835514226)**",
            " <br />"
        ],
        "uint(-1) index for not found": [
            "Functions `getTokenConfigBySymbolHash`, `getTokenConfigByCToken` and `getTokenConfigByUnderlying` check returned index against max uint:",
            "index != uint(-1)",
            "-1 should indicate that the index is not found, however, a default value for an uninitialized uint is 0, so it is impossible to get -1. What is even weirder is that 0 will be returned for non-existing configs but 0 is a valid index for the 1st config.",
            "One of the solutions would be to reserve 0 for a not found index and use it when searching in mappings. Then normal indexes should start from 1. Another solution would be to introduce a new mapping with a boolean value that indicates if this index is initialized or not but this may be a more gas costly way.",
            "**[ghoul-sol (Based Loans) confirmed](https://github.com/code-423n4/2021-04-basedloans-findings/issues/24#issuecomment-835514161):**",
            "> `UniswapConfig` has been refactored. Index 0 is considered a non-existent config and all comparison are against that value.",
            "<br /><br />"
        ]
    },
    "MediumRiskFindings": {
        "Reward rates can be changed through flash borrows": [
            "The rewards per market are proportional to their `totalBorrows` which can be changed by a large holder who deposits lots of collateral, takes out a huge borrow in the market, updates the rewards, and then unwinds the position.",
            "They'll only pay gas fees as the borrow / repay can happen in the same block.",
            "The `Comptroller.refreshCompSpeeds` function only checks that the single transaction is called from an EOA, but miners (or anyone if a miner offers services like flash bundles for flashbots) can still run flash-loan-like attacks by first sending a borrow tx increasing the totalBorrows, then the `refreshCompSpeeds` transaction, and then the repay of the borrow, as miners have full control over the transaction order of the block.",
            "The new rate will then persist until the next call to `refreshCompSpeeds`.",
            "Attackers have an incentive to drive up the rewards in markets they are a large supplier/borrower in.",
            "The increased rewards that the attacker receives are essentially stolen from other legitimate users.",
            "Recommend making it an admin-only function or use a time-weighted total borrow system similar to Uniswap's price oracles.",
            "**[ghoul-sol (Based Loans) confirmed](https://github.com/code-423n4/2021-04-basedloans-findings/issues/33#issuecomment-835539656):**",
            "> Restricting `Comptroller.refreshCompSpeeds` function to admin only would centralize an ability to update speeds. A better solution may be a bot that keeps track of markets utilizations and updates speeds when needed. That will also give a way to community to participate.",
            ">",
            "> Also, higher rewards would mean that all participants are getting them and that would bring even more liquidity to the given market and decrease attackers earnings. Attacker could keep moving the liquidity from market to market but everyone would follow quite quickly. If that actually happens, admin has a way to stop the rewards and make `refreshCompSpeeds` admin-only function as last resolution because comptroller is using proxy pattern.",
            "<br /><br />"
        ]
    }
}