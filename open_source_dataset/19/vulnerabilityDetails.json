{
    "HighRiskFindings": {
        "Anyone can arbitrarily add router liquidity": [
            "_Submitted by 0xRajeev, also found by cmichel and pauliax_",
            "The `addLiquidity()` function takes a router address parameter, whose liquidity is increased (instead of assuming that `router` == `msg.sender` like is done on `removeLiquidity()`) on this contract/chain, by transferring the fund amount from router address to this contract if `assetID` != 0 (i.e. ERC20 tokens). However, anyone can call this function on the router\u2019s behalf. For `assetID` == 0, the Ether transfer via `msg.value` comes from `msg.sender` and hence is assumed to be the router itself.",
            "The impact is that this will allow anyone to call this function and arbitrarily move ERC20 tokens from router address to this contract, assuming router has given max approval to this contract and has `assetID` amount available for transfer. While the router can always remove the liquidity if it doesn\u2019t want to maintain that level of liquidity, this lack of access control or flexibility for a relayer to add liquidity on router\u2019s behalf, may unnecessarily (and without authorization) increase the router\u2019s exposure to protocol risk to more than it desires. See `TransactionManager.sol` [#L88-L98](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88-L98). See also, use of `msg.sender` in `removeLiquidity` ([#L88-L98](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88-L98)).",
            "Recommend considering the use of `msg.sender` in `addLiquidity()` or evaluate this risk otherwise.",
            "**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/48#issuecomment-879189733):**",
            " > The bigger issue here is the typo [here](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L97), if we use the funds from `msg.sender` that means that people are donating funds to the router.",
            ">",
            "> We will fix the `msg.sender`, but allow `addLiquidity` to be callable by anyone",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-connext-findings/issues/48#issuecomment-890607571):**",
            " > This is high risk because funds can be send to the wrong address."
        ],
        "`activeTransactionBlocks` are vulnerable to DDoS attacks": [
            "_Submitted by gpersoon, also found by pauliax and shw_",
            "There is a potential issue in function `removeUserActiveBlocks` and the for loop inside it. I assume you are aware of block gas limits (they may be less relevant on other chains but still needs to be accounted for), so as there is no limit for `activeTransactionBlocks`, it may grow so large that the for loop may never finish. You should consider introducing an upper limit for `activeTransactionBlocks`. Also, a malicious actor may block any account (DDOS) by just calling `prepare` again and again with 0 amount acting as a router. This will push `activeTransactionBlocks` to the specified user until it is no longer possible to remove them from the array.",
            "This is also a gas issue, as function `removeUserActiveBlocks` iterating and assigning large dynamic arrays is very gas-consuming. Consider optimizing the algorithm, e.g. finding the first occurrence, then swap it with the last item, pop the array, and break. Or maybe even using an [`EnumerableMap`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableMap.sol), so you can find and remove elements in `O(1)`.",
            "The best solution depends on what the usual number of `activeTransactionBlocks` is. If it is expected to be low (e.g. less than 5), then the current approach will work. But with larger arrays, I expect `EnumerableMap` would be more efficient.",
            "Because an upper limit will not fully mitigate this issue, as a malicious actor can still DDOS the user by pushing useless txs until this limit is reached and a valid router may not be able to submit new txs. And, because you need to improve both the security _and_ performance of `removeUserActiveBlocks`; `EnumerableMap` may be a go-to solution.",
            "**[LayneHaber (Connext) confirmed](https://github.com/code-423n4/2021-07-connext-findings/issues/27#issuecomment-879509531):**",
            " > https://github.com/connext/nxtp/pull/24"
        ],
        "Router liquidity on receiving chain can be double-dipped by the user": [
            "_Submitted by 0xRajeev, also found by cmichel, gpersoon, pauliax, s1m0 and shw_",
            "During `fulfill()` on the receiving chain, if the user has set up an external contract at `txData.callTo`, the catch blocks for both `IFulfillHelper.addFunds()` and `IFulfillHelper.excute()` perform `transferAsset` to the predetermined fallback address `txData.receivingAddress`.",
            "If `addFunds()` has reverted earlier, `toSend` amount would already have been transferred to the `receivingAddress`. If `execute()` also fails, it is again transferred.",
            "**Scenario:** User sets up receiver chain `txData.callTo` contract such that both `addFunds()` and `execute()` calls revert. That will let him get twice the `toSend` amount credited to the `receivingAddress`. So effectively, Alice locks 100 `tokenAs` on chain A, and can get 200 `tokenAs` (or twice the amount of any token she is supposed to get on chain B from the router), minus relayer fee, on chain B. Router liquidity is double-dipped by Alice and router loses funds. See `TransactionManager.sol` [L395-L409](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L395-L409) and [L413-L428](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L413-L428).",
            "Recommend that the second catch block for `execute()` should likely not have the `transferAsset()` call. It seems like a copy-and-paste bug unless there is some reason that is outside the specified scope and documentation for this contest.",
            "**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/46#issuecomment-880098271):**",
            " > https://github.com/connext/nxtp/pull/39"
        ],
        "Expired transfers will lock user funds on the sending chain": [
            "_Submitted by 0xRajeev_",
            "The cancelling relayer is being paid in `receivingAssetId` on the `sendingChain` instead of in `sendingAssetID`. If the user relies on a relayer to cancel transactions, and that `receivingAssetId` asset does not exist on the sending chain (assuming only `sendingAssetID` on the sending chain and `receivingAssetId` on the receiving chain are assured to be valid and present), then the cancel transaction from the relayer will always revert and user\u2019s funds will remain locked on the sending chain.",
            "The impact is that expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.",
            "Recommend changing `receivingAssetId` to `sendingAssetId` in `transferAsset()` on `TransactionManager.sol` [L514](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L510-L517).",
            "**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/47#issuecomment-879510286):**",
            " > https://github.com/connext/nxtp/pull/25"
        ],
        "`Approval` is not reset if the call to `IFulfillHelper` fails": [
            "_Submitted by pauliax, also found by 0xsanson, cmichel and shw_",
            "The function `fulfill` first approves the `callTo` to transfer an amount of `toSend` tokens and tries to call `IFulfillHelper`, but if the call fails, it transfers these assets directly. However, in such case the approval is not reset, so a malicous `callTo` can pull these tokens later:",
            "```solidity",
            "// First, approve the funds to the helper if needed",
            "    if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {",
            "      require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\");",
            "    }",
            "    // Next, call `addFunds` on the helper. Helpers should internally",
            "    // track funds to make sure no one user is able to take all funds",
            "    // for tx",
            "    if (toSend > 0) {",
            "      try",
            "        IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(",
            "          txData.user,",
            "          txData.transactionId,",
            "          txData.receivingAssetId,",
            "          toSend",
            "        )",
            "      {} catch {",
            "        // Regardless of error within the callData execution, send funds",
            "        // to the predetermined fallback address",
            "        require(",
            "          LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),",
            "          \"fulfill: TRANSFER_FAILED\"",
            "        );",
            "      }",
            "    }",
            "```",
            "[Tuesday, August 10, 2021](x-fantastical3://show/calendar/2021-08-18)",
            "Recommend that `approval` should be placed inside the try/catch block or `approval` needs to be reset if the call fails.",
            "**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/31#issuecomment-880098587):**",
            " > https://github.com/connext/nxtp/pull/39"
        ]
    },
    "MediumRiskFindings": {
        "Signatures use only tx ID instead of entire digest": [
            "_Submitted by cmichel_",
            "The signature check in `recoverFulfillSignature()` only uses transaction ID (along with the relayer fee) which can be accidentally reused by the user, in which case the older signatures with the older relayer fees can be replayed.  The signature should be on the entire digest `hashInvariantTransactionData(txData)` as indicated in the comment on L306.",
            "The impact is that,  If the user signatures are indeed on the digest as indicated by the comment, the signature/address check in `fulfill()` will fail. If not, they may be accidentally/intentionally replayed with same transaction ID, which also appears to be an outstanding question as indicated by the comment on L12.",
            "`recoverCancelSignature()` similarly uses only tx ID.",
            "Unless there is a good reason not to, it is safer to include `hashInvariantTransactionData(txData)` in signatures so that they cannot be replayed with different txData (but same tx ID) whose `preparedBlockNumber` is > 0.",
            "Recommend evaluating if the signature should contain only tx ID, or the entire digest, and then changing the logic appropriately.",
            "**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/54#issuecomment-878569946):**",
            " > User should be able to break up large transfers across multiple routers using the same `transactionId` to keep the transaction  unlocking atomic. For example, say I want to transfer \\$100K, but there are only 8 routers who each have \\$60K available. I should be able to break up the single transaction into \\$20K transactions split across 5 of the routers. When unlocking this, I should only need to broadcast a single signature, so all of the transactions can be unlocked simultaneously.",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-connext-findings/issues/54#issuecomment-890612308):**",
            " > Bumping to medium risk as replay attack can have significant consequences"
        ],
        "Malicious router can block cross-chain-transfers": [
            "_Submitted by 0xRajeev, also found by cmichel and shw_",
            "The agreement between the `user` and the `router` seems to already happen off-chain because all the fields are required for the initial `In variantTransactionData` call already. A router could pretend to take on a user's cross-chain transfer, the user sends their `prepare` transaction, locking up funds on the sending chain.",
            "But then the `router` simply doesn't respond or responds with a `prepare` transaction of `amount=0`.",
            "The user's funds are then locked for the entire expiry time, whereas the router does not have to lock up anything as the amount is 0, even no gas if they simply don't respond. In this way, a router can bid on everything off-chain without a penalty, and take down everyone that accepts the bid.",
            "Recommend that maybe there could be a penalty mechanism for non-responsive routers that agreed off-chain, slashing part of their added liquidity. Could also be that the bid signature already helps with this, but I'm not sure how it works as the off-chain part is not part of the repo.",
            "**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/12#issuecomment-878590098):**",
            " > This is true, and we are building penalty mechanisms outside of these contracts. For now we are considering adding in a permissioned launch, see #49"
        ]
    }
}