{
    "HighRiskFindings": {
        "Missing overflow check in `flashLoan`": [
            "`ERC20FlashMintUpgradeable.flashLoan` does not check for an overflow when adding the fees to the `flashloan` amount.",
            "The functionality might have been copied from https://eips.ethereum.org/EIPS/eip-3156 but this one already has overflow checks as it uses solidity 0.8.0. This leads to an issue where the attacker does not need to pay back the `flashloan` as they will burn 0 tokens:",
            "```solidity",
            "_burn(address(receiver), amount + fee);",
            "```",
            "They end up with a huge profit. (Luckily, this is currently not exploitable as the fee is set to 0 so there's no possibility to overflow. However, if governance decides to change the flashloan fee, flashloans can be taken without having to repay them). Recommend using `SafeMath`.",
            "**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/43#issuecomment-845566980):**",
            " > Upgraded to 0.8.x."
        ],
        "`distribute` DoS on missing `receiveRewards` implementation": [
            "`NFTXEligiblityManager._sendForReceiver` should check `returnData.length == 1` before decoding. Otherwise, if it returns no return data, the `abi.decode` call will revert and with it the whole `distribute` function .",
            "A single poorly implemented `feeReceiver` can break the whole `distribute` function and allow a denial of service by reverting the transaction.",
            "Recommend changing to: `bool tokensReceived = returnData.length == 1 && abi.decode(returnData, (bool));`.",
            "**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/46):**",
            "**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/46#issuecomment-848259748):**",
            " > Marking this as high risk because one nefarious feeReceiver can in fact deny other users to receive their fees"
        ],
        "`getRandomTokenIdFromFund` yields wrong probabilities for ERC1155": [
            "`NFTXVaultUpgradeable.getRandomTokenIdFromFund` does not work with ERC1155 as it does not take the deposited `quantity1155` into account.",
            "Assume `tokenId0` has a count of 100, and `tokenId1` has a count of 1.",
            "Then `getRandomId` would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.",
            "This might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.",
            "Recommend taking the quantities of each token into account (`quantity1155`) which probably requires a design change as it is currently hard to do without iterating over all tokens.",
            "**[0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/56)**",
            "**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/56#issuecomment-848266608):**",
            " > Marking this as high risk as an attacker can weed out high-value NFTs from a vault putting other users funds at risk"
        ],
        "`NFTXLPStaking` Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault": [
            "The LPStaking contract does not require that a stake be locked for any period of time. The LPStaking contract also does not track how long your stake has been locked. So an attacker Alice can stake, claim rewards, and unstake, all in one transaction. If Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.",
            "The fact that the `NFTXVaultUpgradeable` contract contains a native `flashLoan` function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.",
            "Since a flash loan will easily dwarf all of the legitimate stakers' size of stake, the contract will erroneously award nearly all of the rewards to Alice.",
            "1.  Wait until an NFTX vault has accrued any significant amount of fees/rewards",
            "2.  `FlashLoanBorrow` a lot of ETH using any generic flash loan provider",
            "3.  `FlashLoanBorrow` a lot of nftx-vault-token using `NFTXVaultUpgradeable.flashLoan()`",
            "4.  Deposit the ETH and nftx-vault-token's into Uniswap for Uniswap LP tokens by calling `Uniswap.addLiquidity()`",
            "5.  Stake the Uniswap LP tokens in `NFTXLPStaking` by calling `NFTXLPStaking.deposit()`",
            "6.  Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling `NFTXLPStaking.claimRewards()`",
            "7.  Remove LP tokens from `NFTXLPStaking` by calling `NFTXLPStaking.exit()`;",
            "8.  Withdraw ETH and nftx-vault-token's by calling `Uniswap.removeLiquidity()`;",
            "9.  Pay back nftx-vault-token flash loan",
            "10. Pay back ETH flash loan",
            "See [GitHub issue page](https://github.com/code-423n4/2021-05-nftx-findings/issues/88) for an in-depth  example.",
            "Recommend requiring that staked LP tokens be staked for a particular period of time before they can be removed. Although a very short time frame (a few blocks) would avoid flash loan attacks, this attack could still be performed over the course of a few blocks less efficiently. Ideally, you would want the rewards to reflect the product of the amount staked and the duration that they've been staked, as well as having a minimum time staked.",
            "Alternatively, if you really want to allow people to have the ability to remove their stake immediately, then only allow rewards to be claimed for stakes that have been staked for a certain period of time. Users would still be able to remove their LP tokens, but they could no longer siphon off rewards immediately.",
            "**[0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-845695223):**",
            " > After looking at the code, this is not possible. The dividend token code takes into consideration the current unclaimed rewards and when a deposit is made that value is deducted.",
            "**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-848325710):**",
            " > @0xKiwi do you mind showing where in code that occurs?"
        ]
    },
    "MediumRiskFindings": {
        "Randomization of NFTs returned in redeem/swap operations can be brute-forced": [
            "If we assume that certain NFTs in a vault over time will have different market demand/price, then the users will try to redeem those specific NFTs. Even if direct redeems are disabled to prevent such a scenario to default to returning randomized NFTs, a user can brute-forced this on-chain randomization (using nonce + blockhash) by repeatedly trying to redeem/swap from a contract, checking the NFT IDs returned from the function and reverting the transaction if those are not the NFT IDs of specific interest.",
            "The impact will be a subversion of the randomization goal to return random NFTs which cannot be specified by the user.",
            "A [similar exploit happened recently with Meebit NFTs](https://twitter.com/sillytuna/status/1391013965170454540).",
            "Recommend considering only EOA (external only account) for redeem/swap operations to prevent brute-forcing via contracts. Alternatively, make the user commit to pseudo-random IDs before revealing them.",
            "**- [0xKiwi acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/78) **"
        ],
        "Use `safeTransfer`/`safeTransferFrom` consistently instead of `transfer`/`transferFrom`": [
            "It is good to add a `require()` statement that checks the return value of token transfers, or to use something like\u00a0OpenZeppelin\u2019s `safeTransfer`/`safeTransferFrom` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.",
            "While most places use a `require` or `safeTransfer`/`safeTransferFrom`, there are three missing cases in the withdrawal of staking token and rescue of arbitrary tokens sent to the `FeeDistributor` contract.",
            "Reference this similar medium-severity finding from [Consensys Diligence Audit of Fei Protocol](https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call).",
            "Recommend using\u00a0`safeTransfer`/`safeTransferFrom` or `require()` consistently.",
            "**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/79)**"
        ],
        "Fee Distribution Re-Entrancy": [
            "The `distribute` function of `NFTXFeeDistributor` has no access control and will invoke a fallback on the fee receivers, meaning that a fee receiver can re-enter via this function to acquire their allocation repeatedly potentially draining the full balance and sending zero amounts to the rest of the recipients.",
            "A smart contract with a malicious `receiveRewards` function can re-enter the `distribute` function with the same vault ID, thereby causing the exploit.",
            "Recommend that re-entrancy protection should be incorporated into the `distribute` function. I should note that a seemingly innocuous contract can cause this re-entrancy by simply asking the owners of the project to include an upgrade-able contract that is then replaced for a malicious implementation.",
            "**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/11)**"
        ],
        "Unbounded iteration in `NFTXEligiblityManager.distribute` over `_feeReceivers`": [
            "`NFTXEligiblityManager.distribute` iterates over all `_feeReceivers`. If the number of `_feeReceivers` gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call `distribute` at all.",
            "Recommend keeping the number of `_feeReceivers` small.",
            "**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/47)**"
        ],
        "Manager can grief with fees": [
            "The fees in `NFTXVaultUpgradeable` can be set arbitrarily high (no restriction in `setFees`).",
            "The manager can front-run mints and set a huge fee (for example `fee = base`) which transfers user's NFTs to the vault but doesn't mint any pool share tokens in return for the user.",
            "Similar griefing attacks are also possible with other functions besides `mint`.",
            "Recommend checking for a max fee as a percentage of `base` (like 10%) whenever setting fees."
        ],
        "Tokens can get stuck in `NFTXMintRequestEligibility`": [
            "When dealing with ERC721 (instead of 1155) the amounts array is ignored, which leads to an issue.",
            "User can call `NFTXMintRequestEligibility.requestMint` for an ERC721 with `amounts[i] = 0`.",
            "The `ERC721.transferFrom` is still executed but user cannot `reclaimRequestedMint` later and the NFT is stuck as it checks (`amounts[i] > 0`).",
            "Tokens can get stuck.",
            "Also, subscribers to `Request` event could be tricked by specifying `amounts[i] > 1` in the ERC721 case, as only one token was transferred, but the amount multiple quantities get logged.",
            "Recommend that `requestMint`: Check `amounts[i] == 1` in ERC721 case, `amounts[i] > 0` in 1155 case.",
            "**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/59)**"
        ],
        "A malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract.": [
            "A malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract. This causes the fee distributor to double spend the `amountToSend` because the contract incorrectly assumes the returned data is truthful.",
            "`NFTXFeeDistributor.sol`:",
            "```solidity",
            "Line 163: (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);",
            "```",
            "Recommend that you don't trust return data from externally called contracts. Only utilize whether the transaction succeeds to determine if the treasury fallback should be called.",
            "```",
            "Line 165: if (!success) {",
            "```",
            "**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/69#issuecomment-845681145):**",
            " > Nice catch!"
        ],
        "The direct redeem fee can be circumvented": [
            "Since the random NFT is determined in the same transaction a payment or swap is being executed, a malicious actor can revert a transaction if they did not get the NFT they wanted. Combined with utilizing Flashbots miners which do not publish transactions which revert with `FlashbotsCheckAndSend`, there would be no cost to constantly attempting this every block or after the nonce is updated from `getPseudoRand()`.",
            "`NFTXVaultUpgradeable.sol`",
            "```solidity",
            "Line 374: uint256 tokenId = i < specificIds.length",
            "    ? specificIds[i]",
            "    : getRandomTokenIdFromFund();",
            "```",
            "In this way, the `directReedemFee` can be avoided and users may lose out on potential earnings. The code below shows a transfer ownership of ERC20 tokens to attack the contract.",
            "```",
            "function revertIfNotSpecifiedID(uint256 targetTokenID) public {",
            "    NFTXVaultUpgradeable vault = NFTXVaultUpgradeable(_vault);",
            "    uint256[] resultID = vault.redeem(1,[]);",
            "    require(resultID[0] == targetTokenID);",
            "}",
            "```",
            "Recommend using a commit-reveal pattern for NFT swaps and redemptions.",
            "**[0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/71)**",
            "**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/71#issuecomment-848321831):**",
            " > Leaving this as medium risk as it puts user earnings into risk"
        ]
    }
}