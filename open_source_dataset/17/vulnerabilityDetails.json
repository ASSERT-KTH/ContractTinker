{
    "HighRiskFindings": {
        "implicit underflows": [
            "_Submitted by gpersoon, also found by cmichel_",
            "There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert.",
            "* `int256(a-b)` where a and b are uint: For example, if `a=1` and `b=2`, then the intermediate result would be `uint(-1) == 2**256-1`",
            "* `int256(-x)` where x is a uint. For example, if `x=1`, then the intermediate result would be `uint(-1) == 2**256-1`",
            "It's better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x.",
            "From `Exposure.sol` [L178](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178):",
            "```solidity",
            "function sortVaultsByDelta(..)",
            "..",
            "    for (uint256 i = 0; i < N_COINS; i++) {",
            "        // Get difference between vault current assets and vault target",
            "        int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result",
            "```",
            "From `PnL.sol` [L112](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pnl/PnL.sol#L112):",
            "```solidity",
            " function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)...",
            "..",
            " emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result",
            "```",
            "From `Buoy3Pool.sol` [L87](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L87):",
            "```solidity",
            "function safetyCheck() external view override returns (bool) {",
            "    ...",
            "        _ratio = abs(int256(_ratio - lastRatio[i])); // underflow in intermediate result",
            "```",
            "Recommend replacing `int256(a-b)` with `int256(a)-int256(b)`, and replacing `int256(-x)` with `-int256(x)`",
            "**[kristian-gro (Gro) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-gro-findings/issues/6#issuecomment-886260551):**",
            "> Confirmed and We've mitigated this issue in our release version.",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-06-gro-findings/issues/6#issuecomment-886260551):**",
            " > Majority of overflow listed above seems low risk with one exception of `safetyCheck`. Underflow is a real risk here.`safetyCheck` is run every time a deposit is made. Ratios can change and the change does not need to be substantial for it to overflow. For that reason it's a high risk."
        ],
        "`Buoy3Pool.safetyCheck` is not precise and has some assumptions": [
            "_Submitted by cmichel, also found by shw_",
            "The `safetyCheck` function has several issues that impact how precise the checks are:",
            "1. Only checks if the `a/b` and `a/c` ratios are within `BASIS_POINTS`.",
            "By transitivity, `b/c` is only within `2 * BASIS_POINTS` if `a/b` and `a/c` are in range.",
            "For a more precise check whether both USDC and USDT are within range, `b/c` must be checked as well.",
            "2. If `a/b` is within range, this does not imply that `b/a` is within range.",
            "* > \"inverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions\"",
            "* Example: `lastRatio = 1.0`",
            "`ratio: a = 1.0, b = 0.8` => `a/b = 1.25`, `b/a = 0.8`",
            "If `a/b` was used with a 20% range, it'd be out of range, but `b/a` is in range.",
            "3. The NatSpec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both `_ratio` and `lastRatio` are only from Curve. Only `_updateRatios` checks the oracle.",
            "To address this issue, it is recommended to check if `b/c` is within `BASIS_POINTS` .",
            "**[kristian-gro (Gro) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-gro-findings/issues/104#issuecomment-880192089):**",
            " > Makes strong assumption about the range of possible values - small differences between a and b will result in small differences between a/b and b/a - Extreme cases are handled by emergency. Agree on b/c check",
            "**[kristian-gro (Gro) commented](https://github.com/code-423n4/2021-06-gro-findings/issues/104#issuecomment-880192847):**",
            " > medium severity - will only cause stop of deposits/withdrawals against curve, work around to put in emergency mode",
            "**kristian-gro (Gro) commented:**",
            "> Acknowledged, but the differences between variables are in basis points, we've simulated flash loan manipulations of curve and come to the conclusion that this approximation has a sufficiently small error margin to not cause issues.",
            "> The B/C check (usdc/usdt) has been added in release version.",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-06-gro-findings/issues/104#issuecomment-886346641):**",
            " > A possibility of stopping deposits or withdrawals deserves high risk."
        ],
        "Incorrect use of operator leads to arbitrary minting of GVT tokens": [
            "_Submitted by 0xRajeev, also found by pauliax and gpersoon_",
            "The `distributeStrategyGainLoss()` function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced on `msg.sender` by checking that `vaultIndexes[msg.sender]` is a valid index range 1-4. However, the operator used in the `require()` is `||` instead of `&&`, which allows an arbitrary `msg.sender`, i.e. attacker, to bypass the check.",
            "**Scenario**: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value in `vaultIndexes[msg.sender]`, which will fail the `> 0` check, but pass the `<= N_COINS + 1` check (`N_COINS = 3`) because `0 <= 4` which will allow control to go past this check.",
            "Furthermore, on L362, `index=0` will underflow the -1 decrement (due to lack of `SafeMath.sub` and use of < 0.8.0 solc) and the index will be set to `(uint256_MAX - 1)`. This will allow execution to proceed to the \"else\" part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.",
            "The attack control flow:",
            "* -> `Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0)`",
            "* -> `index = 0` passes check for the `index <= N_COINS + 1` part of predicate on L357 in `Controller.sol`",
            "* -> `index = uint256_MAX` after L362",
            "* -> `gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN);` on L371 in `Controller.sol`",
            "* -> `ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);` on L376 in `Controller.sol`",
            "* -> `(gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);` on L254 in `PnL.sol`",
            "* -> `performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);` on L186 of `PnL.sol`",
            "* ->  `gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);` on L256 in `PnL.sol`",
            "Recommend changing `||` to `&&` in `require()` on L357 of `Controller.sol` to prevent arbitrary addresses from going past this check. Or, consider exercising explicit access control for the authorized vault adaptors.",
            "**[kristian-gro (Gro) confirmed](https://github.com/code-423n4/2021-06-gro-findings/issues/69)**",
            "> Confirmed and Fix has been implemented in release version."
        ],
        "`sortVaultsByDelta` doesn't work as expected": [
            "_Submitted by gpersoon, also found by shw_",
            "The function `sortVaultsByDelta` doesn't always work as expected.",
            "Suppose all the delta's are positive, and delta1 >= delta2 >= delta3 > 0. Then `maxIndex = 0`. And `(delta < minDelta (==0) )` is never true, so `minIndex = 0`.",
            "Then (assuming `bigFirst==true`):",
            "```solidity",
            "vaultIndexes[0] = maxIndex = 0",
            "vaultIndexes[2] = minIndex = 0",
            "vaultIndexes[1] = N_COINS - maxIndex - minIndex = 3-0-0 = 3",
            "```",
            "This is clearly not what is wanted, all `vaultIndexes` should be different and should be in the range [0..2]. This is due to the fact that `maxDelta` and `minDelta` are initialized with the value 0. This all could results in withdrawing from the wrong vaults and reverts (because `vaultIndexes`[1]  is out of range).",
            "`Exposure.sol` [L178](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178):",
            "```solidity",
            "function sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {",
            "        uint256 maxIndex;",
            "        uint256 minIndex;",
            "        int256 maxDelta;",
            "        int256 minDelta;",
            "        for (uint256 i = 0; i < N_COINS; i++) {",
            "            // Get difference between vault current assets and vault target",
            "            int256 delta = int256(",
            "                unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)",
            "            );",
            "            // Establish order",
            "            if (delta > maxDelta) {",
            "                maxDelta = delta;",
            "                maxIndex = i;",
            "            } else if (delta < minDelta) {",
            "                minDelta = delta;",
            "                minIndex = i;",
            "            }",
            "        }",
            "        if (bigFirst) {",
            "            vaultIndexes[0] = maxIndex;",
            "            vaultIndexes[2] = minIndex;",
            "        } else {",
            "            vaultIndexes[0] = minIndex;",
            "            vaultIndexes[2] = maxIndex;",
            "        }",
            "        vaultIndexes[1] = N_COINS - maxIndex - minIndex;",
            "    }",
            "```",
            "Recommend the following",
            "1. Initializing `maxDelta` and `minDelta`:",
            "```solidity",
            "        int256 maxDelta = -2**255; // or type(int256).min when using a newer solidity version",
            "        int256 minDelta  = 2**255; // or type(int256).max when using a newer solidity version",
            "```",
            "2. Check that `maxIndex` and `minIndex` are not the same",
            "3. require (`maxIndex` != `minIndex`);",
            "**kristian-gro (Gro) confirmed:**",
            "> Confirmed and Fix has been implemented in release version."
        ]
    },
    "MediumRiskFindings": {
        "Usage of deprecated ChainLink API in `Buoy3Pool`": [
            "_Submitted by cmichel, also found by 0xRajeev and a_delamo_",
            "The Chainlink API (`latestAnswer`) used in the `Buoy3Pool` oracle wrappers is deprecated:",
            "> This API is deprecated. Please see API Reference for the latest Price Feed API. [Chainlink Docs](https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/#latestanswer)",
            "It seems like the old API can return stale data. Checks similar to that of the new API using `latestTimestamp` and `latestRoundare` are needed, as this could lead to stale prices according to the Chainlink documentation:",
            "* [under current notifications: \"if answeredInRound < roundId could indicate stale data.\"](https://docs.chain.link/docs/developer-communications#current-notifications)",
            "* [under historical price data: \"A timestamp with zero value means the round is not complete and should not be used.\"](https://docs.chain.link/docs/historical-price-data#solidity)",
            "Recommend adding checks similar to `latestTimestamp` and `latestRoundare`",
            "```solidity",
            "(",
            "    uint80 roundID,",
            "    int256 price,",
            "    ,",
            "    uint256 timeStamp,",
            "    uint80 answeredInRound",
            ") = chainlink.latestRoundData();",
            "require(",
            "    timeStamp != 0,",
            "    \u201cChainlinkOracle::getLatestAnswer: round is not complete\u201d",
            ");",
            "require(",
            "    answeredInRound >= roundID,",
            "    \u201cChainlinkOracle::getLatestAnswer: stale data\u201d",
            ");",
            "require(price != 0, \"Chainlink Malfunction\u201d);",
            "```",
            "**[kristian-gro (Gro) confirmed](https://github.com/code-423n4/2021-06-gro-findings/issues/106)**",
            "> Confirmed and Fix has been implemented in release version."
        ],
        "Safe addresses can only be added but not removed": [
            "_Submitted by 0xRajeev, also found by pauliax_",
            "The `addSafeAddress()`  takes an address and adds it to a \u201csafe list\". This is used in `eoaOnly()` to give exemption to safe addresses that are trusted smart contracts, when all other smart contacts are prevented from protocol interaction. The stated purpose is to allow only such partner/trusted smart contract integrations (project rep mentioned Argent wallet as the only one for now but that may change) an exemption from potential flash loan threats. But if there is a safe listed integration that needs to be later disabled, it cannot be done. The protocol will have to rely on other measures (outside the scope of this contest) to prevent flash loan manipulations which are specified as an area of critical concern.",
            "**Scenario:** A trusted integration/partner address is added to the safe list. But that wallet/protocol/DApp is later manipulated (by the project, its users or an attacker) to somehow launch a flash loan attack on the protocol. However, its address cannot be removed from the safe list and the protocol cannot prevent flash loan manipulations from that source because of its exemption. Contract/project will have to be redeployed.",
            "Recommend changing `addSafeAddress()` to `isSafeAddress()` with an additional bool parameter to allow both the enabling _AND_ disabling of safe addresses.",
            "**[kristian-gro (Gro) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-gro-findings/issues/51#issuecomment-880043980):**",
            "> low risk - Made specifically for one partner in beta period, and planned to be removed. We added the removal function for sanity.",
            "> ",
            "> Confirmed and Fix has been implemented in release version.",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-06-gro-findings/issues/51#issuecomment-886327301):**",
            " > I'll keep medium risk because this could put the protocol into a one way street and not being able to remove safe addresses is quite dangerous. Medium risk."
        ],
        "`BaseVaultAdaptor` assumes `sharePrice` is always in underlying decimals": [
            "_Submitted by cmichel_",
            "The two `BaseVaultAdaptor.calculateShare` functions compute `share = amount.mul(uint256(10)**decimals).div(sharePrice)`",
            "```solidity",
            "uint256 sharePrice = _getVaultSharePrice();",
            "// amount is in \"token\" decimals, share should be in \"vault\" decimals",
            "share = amount.mul(uint256(10)**decimals).div(sharePrice);",
            "```",
            "This assumes that the `sharePrice` is always in _token_ decimals and that _token_ decimals is the same as _vault_ decimals.",
            "Both these assumptions happen to be correct for Yearn vaults, but that will not necessarily be the case for other protocols.",
            "As this functionality is in the `BaseVaultAdaptor`, and not in the specific `VaultAdaptorYearnV2_032`, consider generalizing the conversion.",
            "Integrating a token where the token or price is reported in a different precision will lead to potential losses as more shares are computed.",
            "Because the conversion seems highly protocol-specific, it is recommended that `calculateShare` should be an abstract function (like `_getVaultSharePrice`) that is implemented in the specific adaptors.",
            "**- [kristian-gro (Gro) confirmed](https://github.com/code-423n4/2021-06-gro-findings/issues/114)**",
            "> Confirmed and shares have been removed from release version."
        ],
        "Flash loan risk mitigation is optional and not robust enough": [
            "_Submitted by 0xRajeev_",
            "The `switchEoaOnly()` allows the owner to disable `preventSmartContracts` (the project\u2019s plan apparently is to do so after the beta-period) which will allow any smart contract to interact with the protocol and potentially exploit any underlying flash loan vulnerabilities which are specified as an area of critical concern.",
            "The current mitigation is to optionally prevent contracts, except whitelisted partner ones, from interacting with the protocol to prevent any flash loan manipulations. A more robust approach would be to add logic preventing multiple txs to the protocol from the same address/`tx.origin` within the same block when smart contracts are allowed. This will avoid any reliance on trust with integrating partners/protocols.",
            "Recommend adding logic that prevents multiple txs to the protocol from the same address and within the same block.",
            "**[kristian-gro (Gro) acknowledged but disagreed with severity](https://github.com/code-423n4/2021-06-gro-findings/issues/52#issuecomment-880041099):**",
            "> Low-severity: This is a temporary blocker to not let SCs interact with gro-protocol, planned to be removed after beta as it might potentially stop other integrations (as per issue 51)",
            "> ",
            "> Acknowledged, this is just a temporary block, and is planned to be removed in future releases - other protection exists to protect the system from flash loan manipulations.",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-06-gro-findings/issues/52#issuecomment-886701698):**",
            " > It looks like a low risk issue since it's a future problem and not something that is an immediate issue, however, it's not clear how the protocol will protect itself against flash loans after this temporary blocker is off. One of the critical protocol's concerns are flash loans manipulations therefore I think medium risk is justified here."
        ],
        "Use of deprecated Chainlink function `latestAnswer`": [
            "_Submitted by shw_",
            "According to Chainlink's documentation ([Deprecated API Reference](https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/), [Migration Instructions](https://docs.chain.link/docs/migrating-to-flux-aggregator/#3-use-the-new-functions), and [API Reference](https://docs.chain.link/docs/price-feeds-api-reference/)), the `latestAnswer` function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, causing an incorrect price to be fed to the `Buoy3Pool`. See `Buoy3Pool.sol` [L207](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L207) and",
            "[L214-L216](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L214-L216).",
            "Recommend using the `latestRoundData` function to get the price instead. Also recommend adding checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:",
            "```solidity",
            "(uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = oracle.latestRoundData();",
            "require(answeredInRound >= roundID, \"...\");",
            "require(timeStamp != 0, \"...\");",
            "```",
            "**[kristian-gro (Gro) disagreed with severity](https://github.com/code-423n4/2021-06-gro-findings/issues/126#issuecomment-879972199):**",
            "> disagree with severity (Low risk)",
            "> Issue would cause deposits and withdrawals to stop, no funds lost",
            "**kristian-gro (Gro) confirmed:**",
            "> Confirmed and shares have been removed from release version.",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-06-gro-findings/issues/126#issuecomment-886824919):**",
            " > In my opinion halting the protocol deserves medium risk. While no funds are lost, from brand perspective it's a second worst thing. Keeping as medium risk."
        ],
        "Early user can break minting": [
            "_Submitted by cmichel_",
            "The protocol computes a `factor` when minting (and burning) tokens, which is the exchange rate of rebase to base tokens (base supply / total assets value), see `GToken.factor()`.",
            "The first user can manipulate this factor such that it always returns `0`.",
            "**Example:**",
            "- Attacker deposits 100.0 DAI and mints 100 * 1e18 PWRD: `DepositHandler.depositGToken` with `dollarAmount = 100.0 = 100 * 1e18`, then `ctrl.mintGToken(pwrd, msg.sender, 1e18)`",
            "calls `gt.mint(account, gt.factor(), amount=1e18)` where `gt.factor()` returns `getInitialBase() = 1e18` because the person is the first minter and it mints `amount * factor / _BASE = 1e18`",
            "- The `ctrl.mintGToken` call also increases total assets: `pnl.increaseGTokenLastAmount(...)`",
            "- The attacker now burns (withdraws) all minted tokens again **except a single wei** using one of the withdrawal functions in `WithdrawHandler`. Because of the withdrawal fee the total assets are only decreased by the post-fee amount (`IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount=userBalance - 1, bonus=fee);`), i.e., with a 2% withdrawal fee the total assets stay at 2% of 100\\$ = 2 * 1e18.",
            "- The result is that `GToken.factor()` always returns `totalSupplyBase().mul(BASE).div(totalAssets) = 1 * 1e18 / (2 * 1e18) = 0`",
            "The resulting `factor` is 0 and thus any user-deposits by `depositGToken` will mint 0 base tokens to the depositor.",
            "This means all deposits and future value accrues to the attacker who holds the only base tokens.",
            "An attacker could even front-run the first minter to steal their deposit this way.",
            "Uniswap solves a similar problem by sending the first 1000 tokens to the zero address which makes the attack 1000x more expensive. The same should work here, i.e., on first mint (`total base supply == 0`), lock some of the first minter's tokens by minting ~1% of the initial amount to the zero address instead of to the first minter.",
            "**[kristian-gro (Gro) acknowledged but disagreed with severity](https://github.com/code-423n4/2021-06-gro-findings/issues/107#issuecomment-879991211):**",
            " > Known issue which will be handled by ops - low risk as gro protocol is the first depositor",
            "**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-06-gro-findings/issues/107#issuecomment-886829344):**",
            " > Even though it's a known issue its consequences are significant. Only because it can be mitigated by ops quite easily, I'll degrade it to medium level."
        ]
    }
}