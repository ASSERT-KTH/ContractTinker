File Path
Unchecked ERC20 transfers can cause lock up
Can access cards of other markets
anyone can call function `sponsor`
Anyone can affect deposits of any user and turn the owner of the token
payout doesn't fix `isForeclosed` state
Critical `uberOwner` address changes should be a two-step process
Missing `balancedBooks` modifier could result in failed system insolvency detection
`minRentalDayDivisor` can be different between markets and treasury
"`RCFactory.createMarket()` does not enforce `_timestamps` and `_timestamps` being larger than `_timestamps`, even though proper functioning requires them to be so"
Possible locked-ether (funds) Issue in `RCOrderbook.sol`
`maxSumOfPrices` check is broken
Flows can bypass market and global pause
Deposit whitelist enforced on `msg.sender` instead of user
Missing call to `removeOldBids` may affect foreclosure
NFT Hub implementation deviates from ERC721 for transfer functions
`RCNftHubL2.safeTransferFrom` not according to spec
Wrong calculation on `_collectRentAction`
Market-specific pause is not checked for sponsor
Deposits don't work with fee-on transfer tokens
Deposits can be denied by abusing `maxContractBalance`
Function `foreclosureTimeUser` returns a shorter user's foreclosure time than expected
Duplication of Balance
auth collision possible
YieldMath.sol / Log2: >= or > ?
Potential griefing with DoS by front-running vault creation with same `vaultID`
Uniswap Oracle uses wrong prices
Witch can't give back vault after 2x grab
User can redeem more tokens by artificially increasing the chi accrual
Uninitialized or Incorrectly set `auctionInterval` may lead to liquidation engine livelock
Violation of implicit constraints in batched operations may break protocol assumptions
Possible DoS attack when creating `Joins` in `Wand`
Users can avoid paying borrowing interest after the fyToken matures
auth only works well with external functions
Unhandled return value of transfer in `transferOut()` of Pools.sol
Flash attack mitigation does not work as intended in USDV.sol
Missing DAO functionality to call `changeDAO()` function in Vader.sol
Proposals can be cancelled
Flash loans can affect governance voting in DAO.sol
Incorrect burn address in Vader.sol
Wrong `calcAsymmetricShare` calculation
Wrong liquidity units calculation
Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol
Anyone can list anchors / curate tokens
Swap token can be traded as fake base token
`getAddedAmount` can return wrong results
4 Synths can be minted with fake base token
Missing access restriction on `lockUnits/unlockUnits`
Wrong slippage protection on Token -> Token trades
Tokens can be stolen through `transferTo`
Transfer fee is burned on wrong accounts
Vault rewards can be gamed
Vault rewards last claim time not always initialized
Vault Weight accounting is wrong for withdrawals
Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether `ExcludedAddresses` List.
Users may unintentionally remove liquidity under a phishing attack.
Anyone can curate pools and steal rewards
Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol
User may not get IL protection if certain functions are called directly in `Pools.sol`
Undefined behavior for DAO and GRANT vote proposals in `DAO.sol`
Lack of input validation in `replacePool()` allows curated pool limit bypass in `Router.sol`
`flashProof` is not flash-proof
Interest debt is capped after a year
Canceled proposals can still be executed
Completed proposals can be voted on and executed again
Divide before multiply
Incorrect operator used in `deploySynth()` of `Pools.sol`
Allowing duplicated anchors could cause bias on anchor price.
Transfer fee avoidance
Init function can be called by everyone
Pool functions can be called before initialization in _`init_()` of Pools.sol
`changeDAO` should be a two-step process in Vader.sol
Copy-paste bug leading to incorrect harvest rewards in Vault.sol
`Vader.redeemToMember()` vulnerable to front running
UniswapConfig getters return wrong token config if token config does not exist
uint(-1) index for not found
Reward rates can be changed through flash borrows
Reward computation is wrong
`LendingPair.liquidateAccount` does not accrue and update `cumulativeInterestRate`
`LendingPair.liquidateAccount` fails if tokens are lent out
Chainlink - Use `latestRoundData` instead of `latestAnswer` to run more validations
`safeTransferFrom` in `TransferHelper` is not `safeTransferFrom`
`_wethWithdrawTo` is vulnerable re-entrancy
Total LP supply & total debt accrual is wrong
Missing overflow check in `flashLoan`
`distribute` DoS on missing `receiveRewards` implementation
`getRandomTokenIdFromFund` yields wrong probabilities for ERC1155
`NFTXLPStaking` Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault
Randomization of NFTs returned in redeem/swap operations can be brute-forced
Use `safeTransfer`/`safeTransferFrom` consistently instead of `transfer`/`transferFrom`
Fee Distribution Re-Entrancy
Unbounded iteration in `NFTXEligiblityManager.distribute` over `_feeReceivers`
Manager can grief with fees
Tokens can get stuck in `NFTXMintRequestEligibility`
A malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract.
The direct redeem fee can be circumvented
`SynthVault` withdraw forfeits rewards
`Pool.sol` & `Synth.sol`: Failing Max Value Allowance
Result of `transfer` / `transferFrom` not checked
Members lose SPARTA tokens in `removeLiquiditySingle()`
Synth `realise` is vulnerable to flash loan attacks
`SynthVault` rewards can be gamed
Missing slippage checks
Dividend reward can be gamed
arbitrary synth mint/burn from pool
Hijack token pool by burning liquidity token
Misuse of AMM model on minting `Synth` (resubmit to add more detail)
wrong `calcLiquidityHoldings` that leads to dead fund in the Pool
Flash loan manipulation on `getPoolShareWeight` of `Utils`
`Dao.sol`: Insufficient validation for proposal creation
Missleading `onlyDAO` modifiers
Improper access control of `claimAllForMember` allows anyone to reduce the weight of a member
_deposit resetting user rewards can be used to grief them and make them loose rewards via `depositForMember`
Pools can be created without initial liquidity
Pool: `approveAndCall` sets unnecessary approval
Synth: `approveAndCall` sets unnecessary approval
`SynthVault` deposit lockup bypass
In the beginning its relatively easy to gain majority share
`grantFunds` will revert after a DAO upgrade.
Block usage of `addCuratedPool`
`BondVault.sol`: Possibly unwithdrawable bondedLP funds in `claimForMember()` + `claimRate` never zeros after full withdrawals
Vulnerable Pool initial rate.
BondVault `BASE` incentive can be gamed
`DEPLOYER` can drain DAOVault funds + manipulate proposal results
Anyone can arbitrarily add router liquidity
`activeTransactionBlocks` are vulnerable to DDoS attacks
Router liquidity on receiving chain can be double-dipped by the user
Expired transfers will lock user funds on the sending chain
`Approval` is not reset if the call to `IFulfillHelper` fails
Signatures use only tx ID instead of entire digest
Malicious router can block cross-chain-transfers
Flash swap call back prior to transferring tokens in `indexPool`
Index Pool always swap to Zero
`IndexPool` pow overflows when `weightRatio` > 10.
IndexPool's `INIT_POOL_SUPPLY` is not fair.
hybrid pool uses wrong `non_optimal_mint_fee`
`IndexPool`:  Poor conversion from Balancer V1's corresponding functions
"`IndexPool.mint` The first liquidity provider is forced to supply assets in the same amount, which may cause a significant amount of fund loss"
"`HybridPool`'s reserve is converted to ""amount"" twice"
Unsafe cast in `IndexPool` mint leads to attack
`IndexPool` initial LP supply computation is wrong
`ConstantProductPool.burnSingle` swap amount computations should use balance
absolute difference is not calculated properly when a > b in MathUtils
Overflow in the `mint` function of `IndexPool` causes LPs' funds to be stolen
Incorrect usage of `_pow` in `_computeSingleOutGivenPoolIn` of `IndexPool`
Incorrect multiplication in `_computeSingleOutGivenPoolIn` of `IndexPool`
Funds in the pool could be stolen by exploiting `flashSwap` in `HybridPool`
No bar fees for `IndexPools`?
`ConstantProductPool` & `HybridPool`: Adding and removing unbalanced liquidity yields slightly more tokens than swap
Router would fail when adding liquidity to index Pool
Router's `complexPath` percentagePaths don't work as expected
`_depositToBentoBox` sometimes uses both ETH and WETH
`withdrawFromWETH` always reverts
`HybridPool`'s `flashSwap` sends entire fee to `barFeeTo`
Rounding errors will occur for tokens without decimals
Approximations may finish with inaccurate values
Users are susceptible to back-running when depositing ETH to `TridenRouter`
implicit underflows
`Buoy3Pool.safetyCheck` is not precise and has some assumptions
Incorrect use of operator leads to arbitrary minting of GVT tokens
`sortVaultsByDelta` doesn't work as expected
Usage of deprecated ChainLink API in `Buoy3Pool`
Safe addresses can only be added but not removed
`BaseVaultAdaptor` assumes `sharePrice` is always in underlying decimals
Flash loan risk mitigation is optional and not robust enough
Use of deprecated Chainlink function `latestAnswer`
Early user can break minting
ERC-721 Enumerable Spec mismatch for index of `tokenByIndex()` function
Signature malleability of EVM's `ecrecover` in `verify()`
Arbitrary Transfer of Unowned NFTs
`Beebots.TradeValid()` Will Erroneously Return True When Maker Is Set To `Address(0)` and `makerIds` Are Set To The `TokenIds` of Unminted Beebot NFTs
function `tokenByIndex` treats last index as invalid
NFT can be minted for free after sale ended
Legacy Function Usage
`randomIndex` is not truly random - possibility of predictably minting a specific token Id
"instead of `call()` , `transfer()` is used to withdraw the ether"
Self transfer can lead to unlimited mint
DAO proposals can be executed by anyone due to vulnerable `TimelockController`
`CompoundToNotionalV2.notionalCallback` ERC20 return values not checked
Access restrictions on `CompoundToNotionalV2.notionalCallback` can be bypassed
Access restrictions on `NotionalV1ToNotionalV2.notionalCallback` can be bypassed
`TokenHandler.safeTransferOut` does not work on non-standard compliant tokens like USDT
`TokenHandler.safeTransferIn` does not work on non-standard compliant tokens like USDT
DOS by Frontrunning NoteERC20 `initialize()` Function
Potential DOS in Contracts Inheriting `UUPSUpgradeable.sol`
Liquidity token value can be manipulated
"TokenHandler.sol, L174 - `.transfer` is bad practice"
`.latestRoundData()` does not update the oracle - `ExchangeRate.sol`
Allowance checks not correctly implemented
`CompoundToNotionalV2.enableToken` ERC20 missing return value check
`nTokenERC20Proxy` emits events even when not success
`TokenHandler.setToken` ERC20 missing return value check
Attackers can force liquidations by borrowing large amounts of an asset.
Re-entrancy bug allows inflating balance
Missing `fromToken != toToken` check
Price feed can be manipulated
Inconsistent usage of `applyInterest`
Wrong liquidation logic
Users are credited more tokens when paying back debt with `registerTradeAndBorrow`
`account.holdsToken` is never set
Rewards cannot be withdrawn
lastUpdatedDay not initialized
function buyBond charges msg.sender twice
Impossible to call withdrawReward fails due to run out of gas
No default `liquidationThresholdPercent`
Missing checks if pairs equal tokens
No entry checks in crossSwap[Exact]TokensFor[Exact]Tokens
maintainer can be pushed out
Several function have no entry check
Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.
diffMaxMinRuntime gets default value of 0
PriceAware uses prices from getAmountsOut
Isolated margin contracts declare but do not set the value of liquidationThresholdPercent
Add a timelock to functions that set key variables
`findNewOwner` edgecase
`UberOwner` has too much power
Uninitialized Variable `marketWhitelist` in `RCTreasury.sol`
Parameter updates not propagated
Deposits don't work with fee-on transfer tokens
A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault
NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens
Approval for NFT transfers is not removed after transfer
Unbounded loop in `_removeNft` could lead to a griefing/DOS attack
Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients
`transferERC721` doesn't clean `timelockERC721s`
`timelockERC721Keys` could exceed the block size limit
Wrong trading pricing calculations
Use of incorrect index leads to incorrect updation of funding rates
Malicious owner can drain the market at any time using `SafetyWithdraw`
Logic error in fee subtraction
Insurance slippage reimbursement can be used to steal insurance fund
Wrong price scale for `GasOracle`
Use of deprecated Chainlink API
No check `transferFrom()` return value
Deflationary tokens are not supported
Underflow problems occurring when a token has >18 decimals
Add reentrancy protections on function `executeTrade`
Single-step process for critical ownership transfer
Malicious owner can arbitrarily change fee to any % value
Missing events for critical parameter changing operations by owner
Wrong funding index in settle when no base?
`prb-math` not audited
Claim liquidation escrow
avoid paying insurance
Trader orders can be front-run and users can be denied from trading
`Controller.setCap` sets wrong vault balance
set cap breaks vault's Balance
No safety check in `addToken`
Controller does not raise an error when there's insufficient liquidity
Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities.
earn results in decreasing share price
`Vault.balance()` mixes normalized and standard amounts
`Vault.withdraw` mixes normalized and standard amounts
`removeToken` would break the vault/protocol.
An attacker can steal funds from multi-token vaults
`VaultHelper` deposits don't work with fee-on transfer tokens
ERC20 return values not checked
`Vault.withdraw` sometimes burns too many shares
Adding asymmetric liquidity in `_addLiquidity` results in fewer LP tokens minted than what should be wanted
Vault: Swaps at parity with swap fee = withdrawal fee
# Controller is vulnerable to sandwich attack
Vault: Withdrawals can be frontrun to cause users to burn tokens without receiving funds in return
`Controller.inCaseStrategyGetStuck` does not update balance
token -> vault mapping can be overwritten
`YAxisVotePower.balanceOf` can be manipulated
wrong YAXIS estimates
Harvest can be frontrun
`manager.allowedVaults` check missing for add/remove strategy
Halting the protocol should be `onlyGovernance` and not` onlyStrategist`
User could lose underlying tokens when redeeming from the `IdleYieldSource`
`YearnV2YieldSource` wrong subtraction in withdraw
`BadgerYieldSource` `balanceOfToken` share calculation seems wrong
withdraw timelock can be circumvented
`IdleYieldSource` doesn't use mantissa calculations
`safeApprove()` for Yearn Vault may revert preventing deposits causing DoS
Return values of ERC20 `transfer` and `transferFrom` are unchecked
`SafeMath` not completely used in yield source contracts
The assumption that operator == to (user) may not hold leading to failed timelock deposits
Actual yield source check on address will succeed for non-existent contract
`YieldSourcePrizePool_canAwardExternal` does not work
Using `transferFrom` on ERC721 tokens
Vault fails to track debt correctly that leads to bad debt
"`FeePoolV0.sol#distributeMochi()` will unexpectedly flush `treasuryShare`, causing the protocol fee cannot be properly accounted for and collected"
`ReferralFeePoolV0.sol#claimRewardAsMochi()` Array out of bound exception
`registerAsset()` can `overwrite _assetClass` value
`debts` calculation is not accurate
Referrer can drain `ReferralFeePoolV0`
Liquidation will never work with non-zero discounts
Anyone can extend withdraw wait period by depositing zero collateral
treasury is vulnerable to sandwich attack
Changing NFT contract in the `MochiEngine` would break the protocol
`treasuryShare` is Overwritten in `FeePoolV0._shareMochi()`
feePool is vulnerable to sandwich attack.
Tokens Can Be Stolen By Frontrunning `VestedRewardPool.vest()` and `VestedRewardPool.lock()`
liquidation factor < collateral factor for Sigma type
`regerralFeePool` is vulnerable to MEV searcher
A malicious user can potentially escape liquidation by creating a dust amount position and trigger the liquidation by themself
Unchecked ERC20 transfer calls
Chainlink's `latestRoundData` might return stale or incorrect results
Debt accrual is path-dependant and inaccurate
Changing engine.nft contract breaks vaults
`UniswapV2/SushiwapLPAdapter` update the wrong token
`UniswapV2TokenAdapter` does not support Sushiswap-only assets
griefing attack to block withdraws
borrow function will borrow max cf when trying to borrow > cf
anyone can create a vault by directly calling the factory
Improper Validation Of `create2` Return Value
`MochiTreasuryV0.withdrawLock()` Is Callable When Locking Has Been Toggled
`MochiTreasuryV0.sol` Is Unusable In Its Current State
